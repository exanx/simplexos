<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simplex OS</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="simplex_os_desktop_style_B.css" id="main-stylesheet">
    <style>
        /* CSS for Blinking Glow Features */
        :root {
            --window-glow-blink-speed: 1.5s; /* Default speed for window glow */
            --start-button-glow-blink-speed: 1.5s; /* Default speed for start button glow */
        }

        /* Active Window Blinking Glow */
        @keyframes windowBlinkGlowAnimation {
            0%, 100% { box-shadow: 0 0 0px var(--_glow-color, transparent); }
            50% { box-shadow: 0 0 20px 5px var(--_glow-color, transparent); }
        }
        body.window-glow-active .window.active {
            --_glow-color: var(--window-active-border-color-custom, var(--window-active-border-color-default-dark)); /* Adapts to theme */
            animation: windowBlinkGlowAnimation var(--window-glow-blink-speed) infinite;
        }

        /* Start Button Blinking Glow */
        @keyframes startButtonGlowAnimation {
            0%, 100% { box-shadow: 0 0 0px transparent; }
            50% { box-shadow: 0 0 15px 3px var(--_start-button-glow-color, var(--accent-primary)); }
        }
        #start-button.blinking-glow-enabled {
            --_start-button-glow-color: var(--start-button-bg, var(--start-button-bg-dark)); /* Uses current start button bg */
            animation: startButtonGlowAnimation var(--start-button-glow-blink-speed) infinite;
        }

        /* Desktop Icon Visibility */
        #desktop.icons-hidden .desktop-icon {
            opacity: 0;
            transform: scale(0.8);
            pointer-events: none;
            visibility: hidden;
        }
        /* Ensure transition for opacity/transform on desktop icons if not already present */
        #desktop .desktop-icon {
            transition: background-color 0.1s ease, opacity 0.3s ease-out, transform 0.3s ease-out, visibility 0s 0.3s;
        }
        body.animations-disabled #desktop .desktop-icon,
        body.animations-disabled #desktop.icons-hidden .desktop-icon {
            transition: none !important;
        }
         body.animations-disabled #desktop.icons-hidden .desktop-icon {
            display: none; /* Fallback for no animations */
        }

        /* Styles for Collapsible Settings Sections */
        .settings-section h3.settings-section-toggle {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none; /* Prevent text selection on toggle click */
            padding: 10px 0; /* Add some padding to make the click target larger if h3 itself had less padding */
            margin-bottom: 0; /* h3's default margin-bottom will be handled by settings-section-content */
        }
        .settings-section h3.settings-section-toggle .collapse-icon {
            transition: transform 0.2s ease-in-out;
            font-size: 0.8em;
            margin-left: 10px;
        }
        .settings-section.collapsed h3.settings-section-toggle .collapse-icon {
            transform: rotate(-90deg);
        }
        .settings-section .settings-section-content {
            max-height: 2000px; /* Sufficiently large height for content */
            overflow: hidden;
            transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out, padding-top 0.3s ease-in-out, margin-top 0.3s ease-in-out;
            opacity: 1;
            margin-top: 18px; /* Replaces old h3 margin-bottom */
        }
        .settings-section.collapsed .settings-section-content {
            max-height: 0;
            opacity: 0;
            margin-top: 0;
            padding-top: 0; /* If content had padding */
            pointer-events: none;
        }
         body.animations-disabled .settings-section .settings-section-content,
                  body.animations-disabled .settings-section.collapsed .settings-section-content {
             display: none;
         }

        /* --- START: Styles for OS Dialog Buttons --- */
        #os-dialog-actions {
            display: flex;
            justify-content: flex-end; /* Aligns buttons to the right */
            gap: 10px;
            padding-top: 20px;
            margin-top: 15px;
            border-top: 1px solid var(--border-secondary, #444);
        }

        #os-dialog-actions button {
            background-color: var(--bg-tertiary, #3a3a3a);
            color: var(--text-primary, #f0f0f0);
            border: 1px solid var(--border-primary, #555);
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            min-width: 80px;
            text-align: center;
            transition: background-color 0.15s ease, border-color 0.15s ease, filter 0.15s ease;
        }

        #os-dialog-actions button:hover {
            background-color: var(--taskbar-button-hover, #4a4a4a);
            border-color: var(--border-secondary, #777);
        }

        /* Style for the primary action button (e.g., OK, Save, Confirm) */
        #os-dialog-actions button.primary,
        #os-dialog-actions button.success {
            background-color: var(--accent-primary, #0078D4);
            color: var(--text-secondary, #ffffff);
            border-color: var(--accent-primary, #0078D4);
            font-weight: bold;
        }

        #os-dialog-actions button.primary:hover,
        #os-dialog-actions button.success:hover {
            background-color: var(--accent-primary, #0078D4); /* Keep base color */
            filter: brightness(1.2); /* Make it glow slightly on hover */
        }
        
        /* Style for the dangerous action button (e.g., Delete, Reset) */
        #os-dialog-actions button.danger {
            background-color: var(--accent-danger, #D32F2F);
            color: var(--text-secondary, #ffffff);
            border-color: var(--accent-danger, #D32F2F);
            font-weight: bold;
        }

        #os-dialog-actions button.danger:hover {
            background-color: var(--accent-danger, #D32F2F);
            filter: brightness(1.2);
        }
        /* --- END: Styles for OS Dialog Buttons --- */

    </style>
</head>
<body>
    <div id="desktop"></div>
    <div id="taskbar"> <button id="start-button"><i class="fa-solid fa-bars"></i> Start</button> <div id="taskbar-apps"></div> <div id="system-tray"><span id="clock"></span></div> </div>
        <div id="start-menu" class="hidden">
        <div id="start-menu-search-bar">
            <i class="fa-solid fa-search"></i>
            <input type="search" id="app-search-input" placeholder="Search for apps...">
        </div>
        <ul id="app-list"></ul>
    </div>
    <div id="taskbar-clock-popup"> <div class="popup-time">--:--:--</div> <div class="popup-date">---</div> </div>

    <div id="lock-screen-overlay" class="hidden"></div>
    <div id="welcome-screen-overlay" class="hidden"></div>
    <div id="custom-context-menu" class="hidden"></div>
    <div id="os-dialog-overlay" class="hidden">
        <div id="os-dialog-box" class="os-dialog">
            <h3 id="os-dialog-title"></h3>
            <div id="os-dialog-content"></div>
            <div id="os-dialog-actions"></div>
        </div>
    </div>


    <input type="file" id="app-file-input" style="display:none;" accept=".js">
    <input type="file" id="image-file-input" style="display:none;" accept="image/*">
    <input type="file" id="wallpaper-file-input" style="display:none;" accept="image/*">
    <input type="file" id="media-file-input" style="display:none;" accept="audio/*,video/*,.mkv,.avi,.mov,.flac,.mp3,.mp4,.ogg,.wav">
    <input type="file" id="custom-css-file-input" style="display:none;" accept=".css">
    <!-- Hidden file input specifically for the image widget -->
    <input type="file" id="widget-image-file-input" style="display:none;" accept="image/*">


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Element References ---
            const desktop = document.getElementById('desktop');
            const taskbar = document.getElementById('taskbar');
            const taskbarApps = document.getElementById('taskbar-apps');
            const startButton = document.getElementById('start-button');
            const startMenu = document.getElementById('start-menu');
            const appList = document.getElementById('app-list');
            const appSearchInput = document.getElementById('app-search-input');
            const appFileInput = document.getElementById('app-file-input');
            const clockElement = document.getElementById('clock');
            const taskbarClockPopup = document.getElementById('taskbar-clock-popup');
            const imageFileInput = document.getElementById('image-file-input');
            const wallpaperFileInput = document.getElementById('wallpaper-file-input');
            const mediaFileInput = document.getElementById('media-file-input');
            const customCSSFileInput = document.getElementById('custom-css-file-input');
            const widgetImageFileInput = document.getElementById('widget-image-file-input'); // Ref for image widget
            const mainStylesheetLink = document.getElementById('main-stylesheet');

            let lockScreenOverlay = document.getElementById('lock-screen-overlay');
            let passwordSetupScreen;
            let loginScreen;
            let welcomeScreenOverlay = document.getElementById('welcome-screen-overlay');
            let customContextMenu = document.getElementById('custom-context-menu');
            
            // --- OS Dialog System Elements ---
            const osDialogOverlay = document.getElementById('os-dialog-overlay');
            const osDialogBox = document.getElementById('os-dialog-box');
            const osDialogTitle = document.getElementById('os-dialog-title');
            const osDialogContent = document.getElementById('os-dialog-content');
            const osDialogActions = document.getElementById('os-dialog-actions');


            // --- State Variables ---
            let openWindows = {};
            let nextZIndex = 10;
            let activeWindowId = null;
            let desktopShortcuts = [];
            let osLocked = true;
            let desktopIconsVisible = true;
            let desktopIconArrangement = 'row';
            let desktopWidgets = {}; // For widget instances
            let nextWidgetZIndex = 5;

            // --- Touch/Tap Interaction Variables ---
            let lastTapTime = 0;
            let lastTapTarget = null;
            const DOUBLE_TAP_THRESHOLD = 300; // milliseconds for double tap
            let longPressTimer = null;
            const LONG_PRESS_DURATION = 700; // milliseconds for long press
            let touchStartX = 0;
            let touchStartY = 0;
            const LONG_PRESS_MOVE_THRESHOLD = 10; // pixels a touch can move and still be a long press


            // --- Storage Keys ---
            const INSTALLED_APPS_STORAGE_KEY = 'simplexos_installed_apps_v2';
            const DESKTOP_SHORTCUTS_KEY = 'simplexos_desktop_shortcuts_v1';
            const BG_COLOR1_KEY = 'simplexos_bg_color1_v1';
            const BG_COLOR2_KEY = 'simplexos_bg_color2_v1';
            const WALLPAPER_KEY = 'simplexos_wallpaper_v1';
            const STARTMENU_VIEW_KEY = 'simplexos_startmenu_view_v1';
            const ANIMATIONS_DISABLED_KEY = 'simplexos_animations_disabled_v1';
            const NOTES_STORAGE_KEY = 'simplexos_notes_app_data_v1';
            const ICON_COLOR_KEY = 'simplexos_icon_color_v1';
            const START_BUTTON_BG_KEY = 'simplexos_start_button_bg_v1';
            const START_MENU_ICON_COLOR_KEY = 'simplexos_start_menu_icon_color_v1';
            const WINDOW_ACTIVE_BORDER_COLOR_KEY = 'simplexos_window_active_border_color_v1';
            const PASSWORD_HASH_KEY = 'simplexos_password_hash_v1';
            const PASSWORD_SETUP_SKIPPED_KEY = 'simplexos_password_setup_skipped_v1';
            const WELCOME_SCREEN_SHOWN_KEY = 'simplexos_welcome_screen_shown_v1';
            const CONTEXT_MENU_ENABLED_KEY = 'simplexos_context_menu_enabled_v1';
            const WINDOW_GLOW_ENABLED_KEY = 'simplexos_window_glow_enabled_v1';
            const WINDOW_GLOW_SPEED_KEY = 'simplexos_window_glow_speed_v1';
            const CUSTOM_CSS_CONTENT_KEY = 'simplexos_custom_css_content_v1';
            const CUSTOM_CSS_FILENAME_KEY = 'simplexos_custom_css_filename_v1';
            const START_BUTTON_GLOW_ENABLED_KEY = 'simplexos_start_button_glow_enabled_v1';
            const DESKTOP_ICONS_VISIBLE_KEY = 'simplexos_desktop_icons_visible_v1';
            const DESKTOP_ICON_ARRANGEMENT_KEY = 'simplexos_desktop_icon_arrangement_v1';
                        // --- Storage Keys ---
            // ... (other keys)
            const TASKBAR_COLOR_KEY = 'simplexos_taskbar_color_v1';
            const APP_LIBRARY_GUIDE_SHOWN_KEY = 'simplexos_app_library_guide_shown_v1'; // <-- ADD THIS LINE
            const DESKTOP_WIDGETS_KEY = 'simplexos_desktop_widgets_v1';
            // ... (other keys) 
            const WIDGET_DATA_PREFIX = 'simplexos_widget_data_';
            const THEME_STYLESHEET_KEY = 'simplexos_theme_stylesheet_v1';
			


            // --- Default Values ---
            let DEFAULT_BG_COLOR1;
            let DEFAULT_BG_COLOR2;
            const DEFAULT_STARTMENU_VIEW = 'list';
            const DEFAULT_WALLPAPERS = [
                'desktop_wallpapers/default_w_1.jpg', 'desktop_wallpapers/default_w_2.jpg',
                'desktop_wallpapers/default_w_3.jpg', 'desktop_wallpapers/default_w_4.jpg',
                'desktop_wallpapers/default_w_5.jpg',
            ];
            let DEFAULT_ICON_COLOR_DARK;
            let DEFAULT_START_BUTTON_BG_DARK;
            let DEFAULT_START_MENU_ICON_COLOR_DARK;
            let DEFAULT_WINDOW_ACTIVE_BORDER_DARK;
            let DEFAULT_BORDER_PRIMARY_DARK;
            let DEFAULT_BORDER_SECONDARY_DARK;
            let DEFAULT_TASKBAR_BG_DARK;
            const DEFAULT_DESKTOP_ICONS_VISIBLE = true;
            const DEFAULT_DESKTOP_ICON_ARRANGEMENT = 'row';
            const AVAILABLE_THEMES = {
                'simplex_os_desktop_style_B.css': 'Simplex Dark (Default)',
                'simplex_os_theme_light.css': 'Simplex Light',
                'simplex_os_theme_futuristic.css': 'Futuristic World',
                'simplex_os_theme_hacker.css': 'Hacker Terminal',
                'simplex_os_theme_solar.css': 'Solar Power',
                'simplex_os_theme_ancient.css': 'Ancient Myths',
                'simplex_os_theme_valentine.css': 'Saint Valentine',
            };
            const DEFAULT_THEME_STYLESHEET = 'simplex_os_desktop_style_B.css';

            // --- Widget Definitions ---
            const widgets = {
                'digitalClock': {
                    name: 'Digital Clock',
                    defaultSize: { width: 290, height: 180 },
                    init: (contentEl, instanceId) => {
                        contentEl.classList.add('digital-clock-widget');
                        contentEl.innerHTML = `
                            <div class="digital-time" id="digital-time-${instanceId}"></div>
                            <div class="digital-date" id="digital-date-${instanceId}"></div>`;

                        const timeEl = contentEl.querySelector(`#digital-time-${instanceId}`);
                        const dateEl = contentEl.querySelector(`#digital-date-${instanceId}`);

                        function updateClock() {
                            const now = new Date();
                            if (timeEl) timeEl.textContent = now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second:'2-digit'});
                            if (dateEl) dateEl.textContent = now.toLocaleDateString(undefined, { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
                        }
                        updateClock();
                        const intervalId = setInterval(updateClock, 1000);

                        if (desktopWidgets[instanceId]) {
                            desktopWidgets[instanceId].cleanup = () => clearInterval(intervalId);
                        }
                    }
                },
                'quickNote': {
                    name: 'Quick Note',
                    defaultSize: { width: 200, height: 200 },
                    init: (contentEl, instanceId) => {
                        const storageKey = `${WIDGET_DATA_PREFIX}${instanceId}`;
                        contentEl.classList.add('quick-note-widget');
                        contentEl.innerHTML = `<textarea placeholder="Type something..."></textarea>`;
                        const textarea = contentEl.querySelector('textarea');
                        
                        const savedContent = localStorage.getItem(storageKey);
                        if (savedContent) textarea.value = savedContent;
                        
                        textarea.addEventListener('input', () => {
                            localStorage.setItem(storageKey, textarea.value);
                        });
                    }
                },
                'imageFrame': {
                    name: 'Image Frame',
                    defaultSize: { width: 180, height: 180 },
                    init: (contentEl, instanceId) => {
                        const storageKey = `${WIDGET_DATA_PREFIX}${instanceId}`;
                        contentEl.classList.add('image-frame-widget');
                        contentEl.innerHTML = `
                            <div class="placeholder" id="placeholder-${instanceId}"><i class="fa-solid fa-image"></i><span>Click to add image</span></div>
                            <img id="image-${instanceId}" class="hidden" />
                        `;
                        const placeholder = contentEl.querySelector(`#placeholder-${instanceId}`);
                        const imageEl = contentEl.querySelector(`#image-${instanceId}`);

                        const loadImage = (dataUrl) => {
                           if(dataUrl) {
                               imageEl.src = dataUrl;
                               imageEl.classList.remove('hidden');
                               placeholder.classList.add('hidden');
                           }
                        };
                        
                        const savedImage = localStorage.getItem(storageKey);
                        if (savedImage) loadImage(savedImage);
                        
                        const selectImage = () => {
                            widgetImageFileInput.onchange = (e) => {
                                const file = e.target.files[0];
                                if (file) {
                                    const reader = new FileReader();
                                    reader.onload = (readEvent) => {
                                        const dataUrl = readEvent.target.result;
                                        localStorage.setItem(storageKey, dataUrl);
                                        loadImage(dataUrl);
                                    };
                                    reader.readAsDataURL(file);
                                }
                                widgetImageFileInput.value = ''; // Reset for next selection
                            };
                            widgetImageFileInput.click();
                        };
                        
                        placeholder.onclick = selectImage;
                        imageEl.onclick = selectImage; // Allow changing the image
                    }
                },
                'todoList': {
                    name: 'To-Do List',
                    defaultSize: { width: 250, height: 300 },
                    init: (contentEl, instanceId) => {
                        const storageKey = `${WIDGET_DATA_PREFIX}${instanceId}`;
                        contentEl.classList.add('todo-list-widget');
                        contentEl.innerHTML = `
                            <input type="text" id="todo-input-${instanceId}" placeholder="Add a task and press Enter...">
                            <ul id="todo-list-${instanceId}"></ul>
                        `;
                        
                        const input = contentEl.querySelector(`#todo-input-${instanceId}`);
                        const list = contentEl.querySelector(`#todo-list-${instanceId}`);
                        
                        let todos = JSON.parse(localStorage.getItem(storageKey)) || [];

                        const saveTodos = () => {
                            localStorage.setItem(storageKey, JSON.stringify(todos));
                        };

                        const renderTodos = () => {
                            list.innerHTML = '';
                            todos.forEach((todo, index) => {
                                const li = document.createElement('li');
                                li.className = todo.completed ? 'completed' : '';
                                li.innerHTML = `<span>${todo.text}</span><button class="delete-btn" data-index="${index}"><i class="fa-solid fa-xmark"></i></button>`;
                                
                                li.querySelector('span').onclick = () => {
                                    todos[index].completed = !todos[index].completed;
                                    saveTodos();
                                    renderTodos();
                                };
                                li.querySelector('.delete-btn').onclick = (e) => {
                                    e.stopPropagation();
                                    todos.splice(index, 1);
                                    saveTodos();
                                    renderTodos();
                                };
                                list.appendChild(li);
                            });
                        };
                        
                        input.onkeypress = (e) => {
                            if (e.key === 'Enter' && input.value.trim() !== '') {
                                if (todos.length >= 32) {
                                    showOSAlert('The To-Do list can hold a maximum of 32 items.', 'List Full');
                                    return;
                                }
                                todos.push({ text: input.value.trim(), completed: false });
                                input.value = '';
                                saveTodos();
                                renderTodos();
                            }
                        };
                        
                        renderTodos();
                    }
                },
                'miniCalculator': {
                    name: 'Mini Calculator',
                    defaultSize: { width: 180, height: 250 },
                    init: (contentEl, instanceId) => {
                        contentEl.classList.add('mini-calc-widget');
                        contentEl.innerHTML = `
                            <div class="display" id="calc-display-${instanceId}">0</div>
                            <div class="buttons">
                                <button data-val="C" class="special">C</button><button class="operator" data-val="/">/</button><button class="operator" data-val="*">*</button><button class="operator" data-val="-">-</button>
                                <button data-val="7">7</button><button data-val="8">8</button><button data-val="9">9</button><button class="operator tall" data-val="+">+</button>
                                <button data-val="4">4</button><button data-val="5">5</button><button data-val="6">6</button>
                                <button data-val="1">1</button><button data-val="2">2</button><button data-val="3">3</button><button class="tall" data-val="=">=</button>
                                <button data-val="0" class="wide">0</button><button data-val=".">.</button>
                            </div>
                        `;

                        const display = contentEl.querySelector(`#calc-display-${instanceId}`);
                        const operators = contentEl.querySelectorAll('.buttons .operator');
                        let currentValue = '0';
                        let operator = null;
                        let previousValue = null;
                        let waitingForOperand = false;

                        const clearActiveOperator = () => operators.forEach(op => op.classList.remove('active'));

                        contentEl.querySelector('.buttons').addEventListener('click', (e) => {
                            if (e.target.tagName !== 'BUTTON') return;
                            const value = e.target.dataset.val;
                            const isOperator = e.target.classList.contains('operator');

                            if ('0123456789'.includes(value)) {
                                if (waitingForOperand) {
                                    currentValue = value;
                                    waitingForOperand = false;
                                } else {
                                    currentValue = currentValue === '0' ? value : currentValue + value;
                                }
                                clearActiveOperator();
                            } else if (value === '.') {
                                if (!currentValue.includes('.')) currentValue += '.';
                            } else if (isOperator) {
                                if (operator && !waitingForOperand) calculate();
                                previousValue = currentValue;
                                operator = value;
                                waitingForOperand = true;
                                clearActiveOperator();
                                e.target.classList.add('active');
                            } else if (value === '=') {
                                calculate();
                                clearActiveOperator();
                            } else if (value === 'C') {
                                currentValue = '0'; operator = null; previousValue = null; waitingForOperand = false;
                                clearActiveOperator();
                            }
                            display.textContent = currentValue.length > 9 ? parseFloat(currentValue).toExponential(3) : currentValue;
                        });

                        function calculate() {
                            if (operator === null || waitingForOperand) return;
                            const prev = parseFloat(previousValue);
                            const curr = parseFloat(currentValue);
                            let result = 0;
                            if (operator === '+') result = prev + curr;
                            else if (operator === '-') result = prev - curr;
                            else if (operator === '*') result = prev * curr;
                            else if (operator === '/') result = prev / curr;
                            
                            currentValue = String(result);
                            operator = null;
                            previousValue = null;
                            waitingForOperand = false;
                        }
                    }
                }
            };

            // --- OS Dialog System ---
            function showOSDialog(options) {
                return new Promise((resolve) => {
                    osDialogTitle.textContent = options.title || 'Message';
                    osDialogContent.innerHTML = ''; // Clear previous content

                    if (options.htmlContent) {
                        osDialogContent.innerHTML = options.htmlContent;
                    } else {
                        const messagePara = document.createElement('p');
                        messagePara.textContent = options.message || '';
                        osDialogContent.appendChild(messagePara);
                    }

                    let inputField = null;
                    if (options.type === 'prompt') {
                        inputField = document.createElement('input');
                        inputField.type = options.inputType || 'text';
                        inputField.value = options.defaultValue || '';
                        osDialogContent.appendChild(inputField);
                    }

                    osDialogActions.innerHTML = '';

                    const closeDialog = (value) => {
                        osDialogOverlay.classList.add('hidden');
                        resolve(value);
                    };

                    options.buttons.forEach(btnConfig => {
                        const button = document.createElement('button');
                        button.textContent = btnConfig.label;
                        button.className = btnConfig.class || '';
                        button.onclick = () => {
                            let value = btnConfig.value;
                            if (options.type === 'prompt' && (value === true || value === undefined)) {
                                value = inputField.value;
                            }
                            closeDialog(value);
                        };
                        osDialogActions.appendChild(button);
                    });

                    osDialogOverlay.classList.remove('hidden');
                    
                    // Focus the most logical element
                    const primaryButton = osDialogActions.querySelector('button.primary') || osDialogActions.querySelector('button.danger') || osDialogActions.querySelector('button');
                    if (inputField) {
                        setTimeout(() => inputField.focus(), 50);
                    } else if (primaryButton) {
                       setTimeout(() => primaryButton.focus(), 50);
                    }
                });
            }

            function showOSAlert(message, title = 'Alert') {
                return showOSDialog({
                    title: title,
                    message: message,
                    type: 'alert',
                    buttons: [{ label: 'OK', value: true, class: 'primary' }]
                });
            }

            function showOSConfirm(message, title = 'Confirm') {
                return showOSDialog({
                    title: title,
                    message: message,
                    type: 'confirm',
                    buttons: [
                        { label: 'Cancel', value: false },
                        { label: 'OK', value: true, class: 'primary' }
                    ]
                });
            }

            function showOSConfirmDanger(message, title = 'Confirm Action') {
                return showOSDialog({
                    title: title,
                    message: message,
                    type: 'confirm',
                    buttons: [
                        { label: 'Cancel', value: false },
                        { label: 'Confirm', value: true, class: 'danger' }
                    ]
                });
            }
            
            function showOSPrompt(message, title = 'Input', defaultValue = '', inputType = 'text') {
                 return showOSDialog({
                    title: title,
                    message: message,
                    type: 'prompt',
                    inputType: inputType,
                    defaultValue: defaultValue,
                    buttons: [
                        { label: 'Cancel', value: null },
                        { label: 'OK', value: true, class: 'primary' }
                    ]
                });
            }

            function showAddWidgetDialog() {
                let listHtml = '<ul class="os-dialog-selection-list">';
                const widgetIcons = {
                    'digitalClock': 'fa-hourglass-half',
                    'quickNote': 'fa-note-sticky',
                    'systemMonitor': 'fa-microchip',
                    'imageFrame': 'fa-image',
                    'todoList': 'fa-list-check',
                    'miniCalculator': 'fa-calculator'
                };
                for (const type in widgets) {
                    const iconClass = widgetIcons[type] || 'fa-puzzle-piece';
                    listHtml += `<li data-widget-type="${type}"><i class="fa-solid ${iconClass}"></i> ${widgets[type].name}</li>`;
                }
                listHtml += '</ul>';

                showOSDialog({
                    title: 'Add Widget',
                    htmlContent: listHtml,
                    buttons: [{ label: 'Cancel', value: null }]
                });

                const listElement = osDialogOverlay.querySelector('.os-dialog-selection-list');
                if (listElement) {
                    listElement.addEventListener('click', (e) => {
                        const li = e.target.closest('li[data-widget-type]');
                        if (li) {
                            const widgetType = li.dataset.widgetType;
                            createWidget(widgetType);
                            // Manually close the dialog
                            osDialogOverlay.classList.add('hidden');
                        }
                    });
                }
            }


            // --- Helper: Get Icon HTML ---
            function getIconHtml(appConfig, size = 'large') {
                 const iconContent = appConfig.icon || '<i class="fa-solid fa-puzzle-piece"></i>';
                 const imgSize = size === 'small' ? '16' : '32';
                 const fontSize = size === 'small' ? '1.1em' : '28px';
                 const containerSize = size === 'small' ? '1.2em' : '32px';

                 if (appConfig.iconPath && appConfig.iconPath.toLowerCase().endsWith('.svg')) {
                     return `<img src="${appConfig.iconPath}" alt="${appConfig.name}" width="${imgSize}" height="${imgSize}">`;
                 } else if (appConfig.iconPath) {
                     return `<span class="icon" style="font-size: ${fontSize}; width: ${containerSize}; height: ${containerSize};">${appConfig.iconPath}</span>`;
                 } else if (typeof iconContent === 'string' && iconContent.trim().toLowerCase().startsWith('<svg')) { // <-- ADD THIS CONDITION
                     return `<span class="icon" style="font-size: ${fontSize}; width: ${containerSize}; height: ${containerSize};">${iconContent}</span>`;
                 } else if (typeof iconContent === 'string' && iconContent.startsWith('<i')) {
                     return `<span class="icon" style="font-size: ${fontSize}; width: ${containerSize}; height: ${containerSize};">${iconContent}</span>`;
                 } else if (typeof iconContent === 'string' && (iconContent.includes('/') || iconContent.startsWith('data:image'))) {
                     return `<img src="${iconContent}" alt="${appConfig.name}" width="${imgSize}" height="${imgSize}">`;
                 } else {
                     return `<span class="icon" style="font-size: ${fontSize}; width: ${containerSize}; height: ${containerSize};"><i class="fa-solid fa-puzzle-piece"></i></span>`;
                 }
            }

            // --- Application Definitions ---
            let apps = {
              
                // -----------------------------------------------------------------------------
                // --- Calculator App ---
                // -----------------------------------------------------------------------------
                 'Calculator': { name: 'Calculator', icon: '<i class="fa-solid fa-calculator"></i>', isCustom: false, init: (contentEl, windowId) => {
                    contentEl.style.padding = '0';
                    contentEl.innerHTML = `<div class="calculator-app"><div class="calculator"><div class="display" id="calc-display-${windowId}"><span class="pending-operator" id="calc-op-${windowId}"></span><span class="main-display">0</span></div><button class="special" data-value="clear">AC</button><button class="special" data-value="negate">+/-</button><button class="special" data-value="%">%</button><button class="operator" data-value="/">÷</button><button data-value="7">7</button><button data-value="8">8</button><button data-value="9">9</button><button class="operator" data-value="*">×</button><button data-value="4">4</button><button data-value="5">5</button><button data-value="6">6</button><button class="operator" data-value="-">−</button><button data-value="1">1</button><button data-value="2">2</button><button data-value="3">3</button><button class="operator" data-value="+">+</button><button data-value="0">0</button><button data-value=".">.</button><button class="operator" data-value="=">=</button></div></div>`;
                     const display = contentEl.querySelector(`#calc-display-${windowId} .main-display`); const opIndicator = contentEl.querySelector(`#calc-op-${windowId}`); const calcContainer = contentEl.querySelector('.calculator'); let currentValue = '0', previousValue = null, operator = null, waitingForOperand = false;
                     function updateDisplay() { let formattedValue = currentValue; try { if (formattedValue !== 'Error' && formattedValue !== 'Infinity' && formattedValue !== '-Infinity') { const num = parseFloat(formattedValue); if (!isNaN(num)) { if (Math.abs(num) > 1e15 || (Math.abs(num) < 1e-9 && num !== 0)) formattedValue = num.toExponential(6); else if (formattedValue.length > 15) { formattedValue = String(num); if(formattedValue.length > 15) formattedValue = num.toPrecision(10); }}}} catch {} display.textContent = formattedValue; const clearButton = calcContainer.querySelector('button[data-value="clear"]'); if (clearButton) clearButton.textContent = (currentValue === '0' || waitingForOperand) && previousValue === null ? 'AC' : 'C'; opIndicator.textContent = operator && waitingForOperand && operator !== '=' ? operator : ''; }
                     function calculate(val1, val2, op) { const num1 = parseFloat(val1); const num2 = parseFloat(val2); if (isNaN(num1) || isNaN(num2)) return 'Error'; switch(op) { case '+': return num1 + num2; case '-': return num1 - num2; case '*': return num1 * num2; case '/': return num2 === 0 ? 'Error' : num1 / num2; default: return num2; } }
                     calcContainer.addEventListener('click', (e) => { if (e.target.tagName !== 'BUTTON') return; const value = e.target.dataset.value; const type = e.target.classList.contains('operator') ? 'operator' : e.target.classList.contains('special') ? 'special' : 'number'; if (value === 'clear') { if (currentValue !== '0' && !waitingForOperand && calcContainer.querySelector('button[data-value="clear"]').textContent === 'C') currentValue = '0'; else { currentValue = '0'; previousValue = null; operator = null; waitingForOperand = false; } } else if (value === 'negate') { if (currentValue !== '0' && currentValue !== 'Error') currentValue = String(parseFloat(currentValue) * -1); } else if (value === '%') { if (currentValue !== 'Error') { currentValue = String(parseFloat(currentValue) / 100); waitingForOperand = false; } } else if (value === '.') { if (currentValue === 'Error') return; if (waitingForOperand) { currentValue = '0.'; waitingForOperand = false; } else if (!currentValue.includes('.')) currentValue += '.'; } else if (type === 'number') { if (currentValue === 'Error') return; if (waitingForOperand || currentValue === '0') { currentValue = value; waitingForOperand = false; } else { if (currentValue.length < 15) currentValue += value; } } else if (type === 'operator') { if (currentValue === 'Error' && value !== '=') { currentValue = '0'; previousValue = null; operator = null; waitingForOperand = false; } if (value === '=') { if (operator && previousValue !== null) { const result = calculate(previousValue, currentValue, operator); currentValue = String(result); previousValue = null; operator = null; waitingForOperand = true; } } else { if (operator && previousValue !== null && !waitingForOperand) { const result = calculate(previousValue, currentValue, operator); currentValue = String(result); previousValue = currentValue; } else { previousValue = currentValue; } operator = value; waitingForOperand = true; } } if (currentValue.length > 18 && !currentValue.includes('e') && currentValue !== 'Error') currentValue = 'Error'; updateDisplay(); calcContainer.querySelectorAll('.operator').forEach(btn => btn.classList.remove('active')); if (operator && waitingForOperand && operator !== '=') { const opButton = calcContainer.querySelector(`button[data-value="${CSS.escape(operator)}"]`); if (opButton) opButton.classList.add('active'); } }); updateDisplay();
                 } },

                // -----------------------------------------------------------------------------
                // --- TextPad App (Enhanced with Font Selection) ---
                // -----------------------------------------------------------------------------
                 'TextPad': { name: 'Text Pad', icon: '<i class="fa-regular fa-file-lines"></i>', isCustom: false, init: (contentEl, windowId) => {
                    contentEl.style.padding = '0'; contentEl.style.overflow = 'hidden';
                    // Added font family selector to the toolbar
                    contentEl.innerHTML = `<div class="textpad-app">
                        <div class="textpad-toolbar">
                            <button id="textpad-save-${windowId}" title="Save As..."><i class="fa-solid fa-save"></i> Save</button>
                            <div class="separator"></div>
                            <label for="textpad-font-family-${windowId}" style="margin: 0 4px 0 8px; font-size: 0.9em;">Font:</label>
                            <select id="textpad-font-family-${windowId}" title="Change Font Family" style="padding: 4px 6px; border-radius: 3px; border: 1px solid var(--border-primary); background-color: var(--paint-toolbar-button-bg); color: var(--paint-toolbar-text); cursor: pointer; max-width: 150px; font-size: 0.9em;"></select>
                            <div class="font-size-controls" style="margin-left: auto; display: flex; align-items: center; gap: 4px;"> <!-- Ensured flex for alignment -->
                                <span style="font-size: 0.9em;">Size:</span>
                                <button id="textpad-font-dec-${windowId}" title="Decrease Font Size"><i class="fa-solid fa-minus"></i></button>
                                <span id="textpad-font-size-indicator-${windowId}" style="font-size: 0.9em; min-width: 30px; text-align: center;">16px</span>
                                <button id="textpad-font-inc-${windowId}" title="Increase Font Size"><i class="fa-solid fa-plus"></i></button>
                            </div>
                        </div>
                        <div class="textpad-content"><textarea id="textpad-textarea-${windowId}" spellcheck="false" placeholder="Start typing..."></textarea></div>
                    </div>`;

                    const textarea = contentEl.querySelector(`#textpad-textarea-${windowId}`);
                    const saveButton = contentEl.querySelector(`#textpad-save-${windowId}`);
                    const fontIncButton = contentEl.querySelector(`#textpad-font-inc-${windowId}`);
                    const fontDecButton = contentEl.querySelector(`#textpad-font-dec-${windowId}`);
                    const fontSizeIndicator = contentEl.querySelector(`#textpad-font-size-indicator-${windowId}`);
                    const fontFamilySelect = contentEl.querySelector(`#textpad-font-family-${windowId}`);

                    const TEXTPAD_STYLE_KEY = 'textpad_style_v1';
                    const FONT_FAMILIES = [
                        { name: "System UI", value: "-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif" },
                        { name: "Arial", value: "Arial, Helvetica, sans-serif" },
                        { name: "Verdana", value: "Verdana, Geneva, sans-serif" },
                        { name: "Tahoma", value: "Tahoma, Geneva, sans-serif" },
                        { name: "Times New Roman", value: "\"Times New Roman\", Times, serif" },
                        { name: "Georgia", value: "Georgia, serif" },
                        { name: "Courier New", value: "\"Courier New\", Courier, monospace" },
                        { name: "Lucida Console", value: "\"Lucida Console\", Monaco, monospace" },
                        { name: "Monospace", value: "monospace" } // Default fallback
                    ];
                    const DEFAULT_TEXTPAD_FONT_FAMILY = "monospace"; // Actual initial default for editor
                    const DEFAULT_TEXTPAD_FONT_SIZE = 16;

                    // Populate font family select
                    FONT_FAMILIES.forEach(font => {
                        const option = document.createElement('option');
                        option.value = font.value;
                        option.textContent = font.name;
                        fontFamilySelect.appendChild(option);
                    });

                    let currentStyle = {
                        fontFamily: DEFAULT_TEXTPAD_FONT_FAMILY,
                        fontSize: DEFAULT_TEXTPAD_FONT_SIZE
                    };

                    function loadStyle() {
                        const storedStyle = localStorage.getItem(TEXTPAD_STYLE_KEY);
                        if (storedStyle) {
                            try {
                                const parsedStyle = JSON.parse(storedStyle);
                                currentStyle.fontFamily = parsedStyle.fontFamily || DEFAULT_TEXTPAD_FONT_FAMILY;
                                currentStyle.fontSize = parseInt(parsedStyle.fontSize, 10) || DEFAULT_TEXTPAD_FONT_SIZE;
                                if (!FONT_FAMILIES.some(f => f.value === currentStyle.fontFamily)) { // Ensure font is valid
                                    currentStyle.fontFamily = DEFAULT_TEXTPAD_FONT_FAMILY;
                                }
                            } catch (e) {
                                console.error("Error parsing TextPad style from localStorage", e);
                                currentStyle.fontFamily = DEFAULT_TEXTPAD_FONT_FAMILY;
                                currentStyle.fontSize = DEFAULT_TEXTPAD_FONT_SIZE;
                            }
                        }
                        applyStyle();
                    }

                    function saveStyle() {
                        try {
                            localStorage.setItem(TEXTPAD_STYLE_KEY, JSON.stringify(currentStyle));
                        } catch (e) {
                            console.error("Error saving TextPad style to localStorage", e);
                            if (window.showOSAlert) { // Check if showOSAlert is available
                                window.showOSAlert("Could not save TextPad style settings. Browser storage might be full.", "Save Error");
                            }
                        }
                    }

                    function applyStyle() {
                        textarea.style.fontFamily = currentStyle.fontFamily;
                        textarea.style.fontSize = `${currentStyle.fontSize}px`;
                        fontSizeIndicator.textContent = `${currentStyle.fontSize}px`;
                        fontFamilySelect.value = currentStyle.fontFamily;
                    }

                    fontIncButton.addEventListener('click', () => {
                        currentStyle.fontSize = Math.min(72, currentStyle.fontSize + 2);
                        applyStyle();
                        saveStyle();
                    });
                    fontDecButton.addEventListener('click', () => {
                        currentStyle.fontSize = Math.max(8, currentStyle.fontSize - 2);
                        applyStyle();
                        saveStyle();
                    });
                    fontFamilySelect.addEventListener('change', () => {
                        currentStyle.fontFamily = fontFamilySelect.value;
                        applyStyle();
                        saveStyle();
                    });

                    saveButton.addEventListener('click', async () => {
                        const textContent = textarea.value;
                        const defaultFilename = "textpad_content.txt";
                         const filename = await showOSDialog({ // Assuming showOSDialog is globally available
                            title: 'Save Text File', message: 'Save file as:', type: 'prompt', defaultValue: defaultFilename,
                            buttons: [ { label: 'Cancel', value: null }, { label: 'Save', value: true, class: 'success' } ]
                        });
                        if (filename === null || filename.trim() === "") return;
                        const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a'); a.href = url; a.download = filename.endsWith('.txt') ? filename : filename + '.txt';
                        a.style.display = 'none'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                    });

                    // Load and apply initial style
                    loadStyle();
                 } },

                // -----------------------------------------------------------------------------
                // --- Paint App (Enhanced) ---
                // -----------------------------------------------------------------------------
                 'Paint': { name: 'Paint', icon: '<i class="fa-solid fa-paintbrush"></i>', isCustom: false, init: (contentEl, windowId) => {
                    contentEl.style.padding = '0';
                    // Updated HTML for the toolbar with new tools and slight reorganization
                    contentEl.innerHTML = `<div class="paint-app"><div class="toolbar">
                        <button id="save-paint-button-${windowId}" title="Save Image"><i class="fa-solid fa-save"></i> Save</button>
                        <button id="clear-canvas-button-${windowId}" title="Clear Canvas"><i class="fa-solid fa-trash-can"></i> Clear</button>
                        <div class="separator"></div>

                        <button class="tool active" data-tool="pencil" title="Pencil"><i class="fa-solid fa-pencil"></i></button>
                        <button class="tool" data-tool="pixelbrush" title="Pixel Brush"><i class="fa-solid fa-vector-square"></i></button>
                        <button class="tool" data-tool="spraybrush" title="Spray Brush"><i class="fa-solid fa-spray-can-sparkles"></i></button>
                        <button class="tool" data-tool="eraser" title="Eraser"><i class="fa-solid fa-eraser"></i></button>
                        <div class="separator"></div>

                        <button class="tool" data-tool="line" title="Line"><i class="fa-solid fa-minus"></i></button>
                        <button class="tool" data-tool="rect" title="Rectangle"><i class="fa-regular fa-square"></i></button>
                        <button class="tool" data-tool="circle" title="Circle"><i class="fa-regular fa-circle"></i></button>
                        <button class="tool" data-tool="triangle" title="Triangle"><i class="fa-solid fa-play fa-rotate-270"></i></button>
                        <input type="checkbox" id="fill-shape-${windowId}" class="tool-option-toggle">
                        <label for="fill-shape-${windowId}" title="Fill Shape"><i class="fa-solid fa-fill"></i> Fill</label>
                        <div class="separator"></div>

                        <button class="tool" data-tool="fill" title="Fill Bucket"><i class="fa-solid fa-fill-drip"></i></button>
                        <button class="tool" data-tool="text" title="Text Tool"><i class="fa-solid fa-font"></i></button>
                        <div class="tool-options" id="text-options-${windowId}" style="display:none;">
                            <label>Text:</label><input type="text" id="text-input-${windowId}" placeholder="Enter text...">
                            <label>Font:</label><input type="number" id="text-size-${windowId}" value="16" min="8" max="100" style="width:50px;">px
                        </div>
                        <div class="separator"></div>
                        <label for="color-${windowId}">Color:</label><input type="color" id="color-${windowId}" value="#000000">
                        <label for="size-${windowId}">Size:</label><input type="range" id="size-${windowId}" min="1" max="50" value="5"><span class="size-indicator" id="size-indicator-${windowId}">5</span>
                    </div><div class="canvas-container">
                        <canvas id="canvas-${windowId}" class="paint-canvas"></canvas>
                        <canvas id="overlay-canvas-${windowId}" class="paint-overlay-canvas"></canvas>
                    </div></div>`;

                    const paintAppEl = contentEl.querySelector('.paint-app'); const canvas = contentEl.querySelector(`#canvas-${windowId}`); const ctx = canvas.getContext('2d', { willReadFrequently: true }); const overlayCanvas = contentEl.querySelector(`#overlay-canvas-${windowId}`); const overlayCtx = overlayCanvas.getContext('2d'); const toolbar = contentEl.querySelector('.toolbar'); const sizeSlider = contentEl.querySelector(`#size-${windowId}`); const colorPicker = contentEl.querySelector(`#color-${windowId}`); const sizeIndicator = contentEl.querySelector(`#size-indicator-${windowId}`); const clearButton = contentEl.querySelector(`#clear-canvas-button-${windowId}`); const saveButton = contentEl.querySelector(`#save-paint-button-${windowId}`); const fillShapeCheckbox = contentEl.querySelector(`#fill-shape-${windowId}`); const textOptionsDiv = contentEl.querySelector(`#text-options-${windowId}`); const textInput = contentEl.querySelector(`#text-input-${windowId}`); const textSizeInput = contentEl.querySelector(`#text-size-${windowId}`);

                    let isDrawing = false, isDrawingShape = false; let currentTool = 'pencil', currentColor = '#000000', currentSize = 5; let lastX, lastY, startX, startY; let isFillingShapes = false; let resizeObserver = null;
                    let canvasMouseIsOver = false; let lastKnownCanvasX = 0; let lastKnownCanvasY = 0;
                    let currentPaintTouchId = null;
                    let trianglePoints = []; // For the new triangle tool

                    function getCanvasTouchPos(canvasEl, touch) { const rect = canvasEl.getBoundingClientRect(); return { x: touch.clientX - rect.left, y: touch.clientY - rect.top }; }
                    function setCanvasDefaults() { const bg = getComputedStyle(canvas).getPropertyValue('--paint-canvas-bg').trim()||'#ffffff'; ctx.fillStyle = bg; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.strokeStyle = currentColor; ctx.lineWidth = currentSize; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.globalCompositeOperation = 'source-over'; }
                    function resizeCanvases() { const cont = paintAppEl.querySelector('.canvas-container'); const w = cont.clientWidth; const h = cont.clientHeight; if (w>0 && h>0) { let temp = null; if (canvas.width>0 && canvas.height>0) { temp=document.createElement('canvas'); temp.width=canvas.width; temp.height=canvas.height; temp.getContext('2d').drawImage(canvas,0,0); } canvas.width=w; canvas.height=h; overlayCanvas.width=w; overlayCanvas.height=h; setCanvasDefaults(); if(temp) ctx.drawImage(temp,0,0); } }

                    function drawTextPreview() { overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height); if (currentTool !== 'text' || !canvasMouseIsOver) return; const txt = textInput.value.trim(); const sz = textSizeInput.value || 16; if (txt) { overlayCtx.font = `${sz}px sans-serif`; overlayCtx.fillStyle = currentColor; overlayCtx.textAlign = 'left'; overlayCtx.textBaseline = 'top'; overlayCtx.fillText(txt, lastKnownCanvasX, lastKnownCanvasY); }}

                    function setActiveTool(tool) {
                        if (currentTool === 'text' && tool !== 'text') overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                        currentTool = tool; trianglePoints = []; // Reset for triangle tool
                        toolbar.querySelectorAll('.tool').forEach(b=>b.classList.remove('active')); const btn = toolbar.querySelector(`button[data-tool="${tool}"]`); if(btn) btn.classList.add('active');
                        textOptionsDiv.style.display = (tool === 'text') ? 'inline-flex' : 'none'; // Changed from classList.toggle
                        canvas.classList.remove('text-cursor','shape-cursor','fill-cursor');
                        if(tool==='text'){ canvas.classList.add('text-cursor'); drawTextPreview(); }
                        else if(['line','rect','circle', 'triangle'].includes(tool)) { canvas.classList.add('shape-cursor'); } // shape-cursor is crosshair
                        else if(tool === 'fill') { canvas.classList.add('fill-cursor'); }
                        else { canvas.style.cursor='crosshair'; } // pencil, eraser, pixelbrush, spraybrush
                    }

                    function drawLine(c,x1,y1,x2,y2){c.beginPath();c.moveTo(x1,y1);c.lineTo(x2,y2);c.stroke();}
                    function drawRect(c,x,y,w,h,f){if(f)c.fillRect(x,y,w,h);else c.strokeRect(x,y,w,h);}
                    function drawCircle(c,x,y,r,f){c.beginPath();c.arc(x,y,r,0,Math.PI*2);if(f)c.fill();else c.stroke();}
                    function drawTriangle(c, p1, p2, p3, fill) { c.beginPath(); c.moveTo(p1.x, p1.y); c.lineTo(p2.x, p2.y); c.lineTo(p3.x, p3.y); c.closePath(); if(fill) c.fill(); else c.stroke(); }
                    function hexToRgbArrayLocal(hex) { let bigint = parseInt(hex.slice(1), 16); let r = (bigint >> 16) & 255; let g = (bigint >> 8) & 255; let b = bigint & 255; return [r, g, b]; }
                    function floodFill(sX, sY, fillColor) { const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height); const data = imageData.data; const width = canvas.width; const height = canvas.height; const stack = [[sX, sY]]; const startIdx = (sY * width + sX) * 4; const targetColor = [data[startIdx], data[startIdx + 1], data[startIdx + 2], data[startIdx + 3]]; const fillColorRgb = hexToRgbArrayLocal(fillColor); if (targetColor[0] === fillColorRgb[0] && targetColor[1] === fillColorRgb[1] && targetColor[2] === fillColorRgb[2] && targetColor[3] === 255) return; const visited = new Uint8Array(width * height); while (stack.length > 0) { const [x, y] = stack.pop(); if (x < 0 || x >= width || y < 0 || y >= height || visited[y * width + x]) continue; const idx = (y * width + x) * 4; if (data[idx] === targetColor[0] && data[idx+1] === targetColor[1] && data[idx+2] === targetColor[2] && data[idx+3] === targetColor[3]) { data[idx] = fillColorRgb[0]; data[idx + 1] = fillColorRgb[1]; data[idx + 2] = fillColorRgb[2]; data[idx + 3] = 255; visited[y * width + x] = 1; stack.push([x + 1, y]); stack.push([x - 1, y]); stack.push([x, y + 1]); stack.push([x, y - 1]); }} ctx.putImageData(imageData, 0, 0); }

                    function handlePaintStart(e, isTouch = false) {
                        const point = isTouch ? getCanvasTouchPos(canvas, e.changedTouches[0]) : { x: e.offsetX, y: e.offsetY };
                        if (isTouch) { if (e.touches.length > 1 && currentTool !== 'text') return; currentPaintTouchId = e.changedTouches[0].identifier; }
                        lastX = point.x; lastY = point.y; startX = point.x; startY = point.y;

                        if (currentTool === 'fill') { isDrawing = false; try { floodFill(startX, startY, currentColor); } catch (err) { console.error("Flood fill error:", err); showOSAlert("Flood fill operation failed.", "Fill Error"); } if (isTouch) e.preventDefault(); return; }
                        if (currentTool === 'text') { overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height); const txt = textInput.value.trim(); const sz = textSizeInput.value || 16; if (txt) { ctx.font = `${sz}px sans-serif`; ctx.textAlign = 'left'; ctx.textBaseline = 'top'; ctx.fillStyle = currentColor; ctx.fillText(txt, lastX, lastY); } isDrawing = false; return; }
                        
                        isDrawing = true;
                        ctx.lineWidth = (currentTool === 'pencil' || currentTool === 'eraser' || ['line','rect','circle','triangle'].includes(currentTool)) ? currentSize : 1; // Brushes might have fixed point size
                        ctx.strokeStyle = currentColor; ctx.fillStyle = currentColor;
                        overlayCtx.lineWidth = currentSize; overlayCtx.strokeStyle = currentColor; overlayCtx.fillStyle = currentColor; overlayCtx.lineCap = 'round'; overlayCtx.lineJoin = 'round';
                        overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);

                        if (currentTool === 'triangle') {
                            trianglePoints.push({ x: startX, y: startY });
                            if (trianglePoints.length === 3) {
                                drawTriangle(ctx, trianglePoints[0], trianglePoints[1], trianglePoints[2], isFillingShapes);
                                trianglePoints = []; isDrawing = false; // Drawing complete
                            }
                        } else if (currentTool === 'pencil' || currentTool === 'eraser') {
                            ctx.globalCompositeOperation = (currentTool === 'eraser') ? 'destination-out' : 'source-over';
                            ctx.beginPath(); ctx.moveTo(lastX, lastY);
                        } else if (currentTool === 'pixelbrush') {
                            ctx.globalCompositeOperation = 'source-over';
                            const size = parseInt(currentSize);
                            ctx.fillRect(startX - size / 2, startY - size / 2, size, size);
                        } else if (currentTool === 'spraybrush') {
                            ctx.globalCompositeOperation = 'source-over';
                            // Spray effect is continuous, handled in move
                        } else if (['line', 'rect', 'circle'].includes(currentTool)) {
                            isDrawingShape = true;
                        }
                        if (isTouch && (isDrawing || isDrawingShape) && currentTool !== 'text') e.preventDefault();
                    }

                    function handlePaintMove(e, isTouch = false) {
                        let point; if (isTouch) { if (e.touches.length > 1 && currentTool !== 'text') return; const touch = Array.from(e.changedTouches).find(t => t.identifier === currentPaintTouchId); if (!touch) return; point = getCanvasTouchPos(canvas, touch); } else { point = { x: e.offsetX, y: e.offsetY }; }
                        lastKnownCanvasX = point.x; lastKnownCanvasY = point.y;
                        if (currentTool === 'text' && !isDrawing) { drawTextPreview(); return; }
                        if (!isDrawing) return;
                        const [cx,cy] = [point.x, point.y];

                        if (currentTool === 'pencil' || currentTool === 'eraser') { ctx.lineTo(cx,cy); ctx.stroke(); }
                        else if (currentTool === 'pixelbrush') { const size = parseInt(currentSize); ctx.fillRect(cx - size/2, cy - size/2, size, size); }
                        else if (currentTool === 'spraybrush') { const sprayRadius = parseInt(currentSize); const sprayDensity = 10 + sprayRadius / 2; for (let i = 0; i < sprayDensity; i++) { const angle = Math.random() * 2 * Math.PI; const radius = Math.random() * sprayRadius; const dotX = cx + Math.cos(angle) * radius; const dotY = cy + Math.sin(angle) * radius; ctx.fillRect(dotX, dotY, 1, 1); }}
                        else if (isDrawingShape && ['line', 'rect', 'circle'].includes(currentTool)) { overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height); const [dx,dy] = [cx-startX, cy-startY]; if (currentTool === 'line') { drawLine(overlayCtx,startX,startY,cx,cy); } else if (currentTool === 'rect') { drawRect(overlayCtx,startX,startY,dx,dy,isFillingShapes); } else if (currentTool === 'circle') { const r=Math.max(1,Math.sqrt(dx*dx+dy*dy)/2); const[cenX,cenY]=[startX+dx/2,startY+dy/2]; drawCircle(overlayCtx,cenX,cenY,r,isFillingShapes); } }
                        else if (currentTool === 'triangle' && trianglePoints.length > 0 && trianglePoints.length < 3) { overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height); if (trianglePoints.length === 1) { drawLine(overlayCtx,trianglePoints[0].x,trianglePoints[0].y,cx,cy); } else if (trianglePoints.length === 2) { drawTriangle(overlayCtx,trianglePoints[0],trianglePoints[1],{x:cx,y:cy},isFillingShapes); }}
                        [lastX,lastY] = [cx,cy];
                        if (isTouch && (isDrawing || isDrawingShape)) e.preventDefault();
                    }

                    function handlePaintEnd(e, isTouch = false) {
                        let point; if (isTouch) { const touch = Array.from(e.changedTouches).find(t => t.identifier === currentPaintTouchId); if (!touch) return; point = getCanvasTouchPos(canvas, touch); currentPaintTouchId = null; } else { point = { x: e.offsetX, y: e.offsetY }; }
                        if (currentTool === 'triangle') { if (trianglePoints.length < 3) isDrawing = true; else isDrawing = false; return; } // Triangle drawing completes on 3rd click (mousedown)
                        if (!isDrawing || currentTool === 'fill') { isDrawing = false; isDrawingShape = false; return; }
                        const [cx,cy] = [point.x, point.y];
                        if (isDrawingShape && ['line', 'rect', 'circle'].includes(currentTool)) { overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height); const [dx,dy] = [cx-startX, cy-startY]; if (currentTool === 'line') { drawLine(ctx,startX,startY,cx,cy); } else if (currentTool === 'rect') { drawRect(ctx,startX,startY,dx,dy,isFillingShapes); } else if (currentTool === 'circle') { const r=Math.max(1,Math.sqrt(dx*dx+dy*dy)/2); const[cenX,cenY]=[startX+dx/2,startY+dy/2]; drawCircle(ctx,cenX,cenY,r,isFillingShapes); } }
                        else if (currentTool === 'pencil' || currentTool === 'eraser') { ctx.lineTo(cx,cy); ctx.stroke(); ctx.globalCompositeOperation = 'source-over'; }
                        // Pixelbrush & Spraybrush draw directly in handlePaintMove
                        isDrawing = false; isDrawingShape = false;
                    }

                    canvas.addEventListener('mouseenter', () => { canvasMouseIsOver = true; if (currentTool === 'text') drawTextPreview(); });
                    canvas.addEventListener('mousedown', (e) => handlePaintStart(e, false));
                    canvas.addEventListener('mousemove', (e) => handlePaintMove(e, false));
                    canvas.addEventListener('mouseup', (e) => handlePaintEnd(e, false));
                    canvas.addEventListener('mouseleave', (e)=>{ canvasMouseIsOver = false; if (currentTool === 'text') overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height); if(isDrawing && !isDrawingShape && (currentTool === 'pencil' || currentTool === 'eraser')){ ctx.stroke(); ctx.globalCompositeOperation='source-over'; } else if (isDrawing && isDrawingShape && ['line', 'rect', 'circle'].includes(currentTool)) { const[dx,dy]=[lastX-startX,lastY-startY]; overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height); if(currentTool==='line')drawLine(ctx,startX,startY,lastX,lastY); else if(currentTool==='rect')drawRect(ctx,startX,startY,dx,dy,isFillingShapes); else if(currentTool==='circle'){const r=Math.max(1,Math.sqrt(dx*dx+dy*dy)/2);drawCircle(ctx,startX+dx/2,startY+dy/2,r,isFillingShapes);} } if (currentTool === 'triangle' && trianglePoints.length > 0) { trianglePoints = []; overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height); } isDrawing=false;isDrawingShape=false; });
                    canvas.addEventListener('touchstart', (e) => handlePaintStart(e, true), { passive: false });
                    canvas.addEventListener('touchmove', (e) => handlePaintMove(e, true), { passive: false });
                    canvas.addEventListener('touchend', (e) => handlePaintEnd(e, true));
                    canvas.addEventListener('touchcancel', (e) => handlePaintEnd(e, true)); // Treat cancel like touchend for cleanup

                    toolbar.addEventListener('click', (e)=>{const t=e.target.closest('button[data-tool]');if(t?.dataset.tool)setActiveTool(t.dataset.tool);});
                    fillShapeCheckbox.addEventListener('change',(e)=>{isFillingShapes=e.target.checked; const l=toolbar.querySelector(`label[for="${e.target.id}"]`); if(l)l.classList.toggle('active',isFillingShapes);});
                    colorPicker.addEventListener('input',(e)=>{currentColor=e.target.value; if (currentTool === 'text') drawTextPreview();});
                    sizeSlider.addEventListener('input',(e)=>{currentSize=e.target.value;sizeIndicator.textContent=currentSize;});
                    textInput.addEventListener('input', () => { if (currentTool === 'text') drawTextPreview(); });
                    textSizeInput.addEventListener('input', () => { if (currentTool === 'text') drawTextPreview(); });
                    clearButton.addEventListener('click', async ()=>{if(await showOSConfirmDanger('Are you sure you want to clear the entire canvas? This cannot be undone.', 'Clear Canvas'))setCanvasDefaults();});
                    saveButton.addEventListener('click', async () => {
                        const f = await showOSDialog({ title: 'Save Image', message: 'Save image as:', type: 'prompt', defaultValue: 'drawing.png', buttons: [ { label: 'Cancel', value: null }, { label: 'Save', value: true, class: 'success' } ] });
                        if (f === null || f.trim() === "") return;
                        try { const u = canvas.toDataURL('image/png'); const a = document.createElement('a'); a.href = u; a.download = f.includes('.') ? f : f + '.png'; a.style.display = 'none'; document.body.appendChild(a); a.click(); document.body.removeChild(a); } catch (err) { console.error("Save canvas err:", err); await showOSAlert("Error saving image.", "Save Error"); }
                    });
                    if(typeof ResizeObserver!=='undefined'){resizeObserver=new ResizeObserver(()=>window.requestAnimationFrame(resizeCanvases));resizeObserver.observe(paintAppEl.querySelector('.canvas-container'));}else{const pw=openWindows[windowId]?.element;if(pw)pw.addEventListener('resize',()=>setTimeout(resizeCanvases,100));}
                    setTimeout(()=>{resizeCanvases();setCanvasDefaults();setActiveTool('pencil');},50);
                    if(openWindows[windowId])openWindows[windowId].cleanup=()=>{if(resizeObserver)resizeObserver.disconnect();};
                 } },

                // -----------------------------------------------------------------------------
                // --- ImageViewer App ---
                // -----------------------------------------------------------------------------
                 'ImageViewer': { name: 'Image Viewer', icon: '<i class="fa-solid fa-image"></i>', isCustom: false, init: (contentEl, windowId) => {
                    contentEl.style.padding = '0';
                    contentEl.innerHTML = `<div class="image-viewer-app">
                        <div class="iv-toolbar iv-main-toolbar">
                            <button id="iv-open-${windowId}" title="Open Image"><i class="fa-solid fa-folder-open"></i></button>
                            <button id="iv-save-${windowId}" title="Save Image As..." disabled><i class="fa-solid fa-save"></i></button>
                            <div class="separator"></div>
                            <button id="iv-zoom-out-${windowId}" title="Zoom Out (-)" disabled><i class="fa-solid fa-search-minus"></i></button>
                            <input type="range" id="iv-zoom-slider-${windowId}" class="zoom-slider-bar" title="Zoom" min="0.1" max="10" step="0.01" value="1" disabled>
                            <button id="iv-zoom-in-${windowId}" title="Zoom In (+)" disabled><i class="fa-solid fa-search-plus"></i></button>
                            <span class="zoom-display" id="iv-zoom-display-${windowId}">--%</span>
                            <div class="separator"></div>
                            <button id="iv-fit-${windowId}" title="Fit to Window" disabled><i class="fa-solid fa-compress-arrows-alt"></i></button>
                            <button id="iv-actual-${windowId}" title="Actual Size (100%)" disabled><i class="fa-solid fa-expand"></i></button>
                            <div class="separator"></div>
                            <button id="iv-toggle-edit-${windowId}" title="Toggle Edit Tools" disabled><i class="fa-solid fa-pen-to-square"></i></button>
                        </div>
                        <div class="iv-toolbar iv-edit-toolbar" id="iv-edit-toolbar-${windowId}" style="display: none;">
                             <button data-tool="crop" title="Crop"><i class="fa-solid fa-crop-simple"></i></button>
                             <button data-tool="resize" title="Resize"><i class="fa-solid fa-arrows-up-down-left-right"></i></button>
                             <div class="separator"></div>
                             <button data-tool="rotate-left" title="Rotate Left"><i class="fa-solid fa-rotate-left"></i></button>
                             <button data-tool="rotate-right" title="Rotate Right"><i class="fa-solid fa-rotate-right"></i></button>
                             <button data-tool="flip-h" title="Flip Horizontal"><i class="fa-solid fa-arrows-left-right"></i></button>
                             <button data-tool="flip-v" title="Flip Vertical"><i class="fa-solid fa-arrows-up-down"></i></button>
                             <div class="separator"></div>
                             <button data-tool="filters" title="Adjust Filters"><i class="fa-solid fa-wand-magic-sparkles"></i></button>
                             <div class="separator"></div>
                             <button data-tool="reset" title="Reset All Changes"><i class="fa-solid fa-undo"></i></button>
                        </div>
                        <div class="iv-toolbar iv-contextual-toolbar" id="iv-contextual-toolbar-${windowId}" style="display: none;"></div>
                        <div class="iv-filter-controls" id="iv-filter-controls-${windowId}" style="display: none;">
                            <div class="filter-item"><label for="iv-brightness-${windowId}">Brightness</label><input type="range" id="iv-brightness-${windowId}" min="0" max="200" value="100"><span class="filter-value" id="iv-brightness-val-${windowId}">100%</span></div>
                            <div class="filter-item"><label for="iv-contrast-${windowId}">Contrast</label><input type="range" id="iv-contrast-${windowId}" min="0" max="200" value="100"><span class="filter-value" id="iv-contrast-val-${windowId}">100%</span></div>
                            <div class="filter-item"><label for="iv-saturate-${windowId}">Saturation</label><input type="range" id="iv-saturate-${windowId}" min="0" max="200" value="100"><span class="filter-value" id="iv-saturate-val-${windowId}">100%</span></div>
                            <div class="filter-item"><label for="iv-hue-${windowId}">Hue</label><input type="range" id="iv-hue-${windowId}" min="0" max="360" value="0"><span class="filter-value" id="iv-hue-val-${windowId}">0°</span></div>
                        </div>
                        <div class="iv-content-area" id="iv-content-area-${windowId}">
                            <canvas class="iv-canvas" id="iv-canvas-${windowId}"></canvas>
                            <canvas class="iv-crop-overlay-canvas" id="iv-crop-overlay-${windowId}"></canvas>
                            <span class="placeholder" id="iv-placeholder-${windowId}">Open an image file to view or edit.</span>
                        </div>
                    </div>`;

                    const appEl = contentEl.querySelector('.image-viewer-app'); const mainCanvas = contentEl.querySelector(`#iv-canvas-${windowId}`); const mainCtx = mainCanvas.getContext('2d'); const overlayCanvas = contentEl.querySelector(`#iv-crop-overlay-${windowId}`); const overlayCtx = overlayCanvas.getContext('2d'); const contentArea = contentEl.querySelector(`#iv-content-area-${windowId}`); const placeholder = contentEl.querySelector(`#iv-placeholder-${windowId}`); const openBtn = contentEl.querySelector(`#iv-open-${windowId}`); const saveBtn = contentEl.querySelector(`#iv-save-${windowId}`); const zoomInBtn = contentEl.querySelector(`#iv-zoom-in-${windowId}`); const zoomOutBtn = contentEl.querySelector(`#iv-zoom-out-${windowId}`); const zoomSlider = contentEl.querySelector(`#iv-zoom-slider-${windowId}`); const zoomDisplay = contentEl.querySelector(`#iv-zoom-display-${windowId}`); const fitBtn = contentEl.querySelector(`#iv-fit-${windowId}`); const actualBtn = contentEl.querySelector(`#iv-actual-${windowId}`); const toggleEditBtn = contentEl.querySelector(`#iv-toggle-edit-${windowId}`); const editToolbar = contentEl.querySelector(`#iv-edit-toolbar-${windowId}`); const contextualToolbar = contentEl.querySelector(`#iv-contextual-toolbar-${windowId}`); const filterControls = contentEl.querySelector(`#iv-filter-controls-${windowId}`);
                    mainCanvas.style.top = '0'; mainCanvas.style.left = '0'; overlayCanvas.style.top = '0'; overlayCanvas.style.left = '0';
                    let originalImage = null, currentImageBitmap = null; let filename = "image.png"; let isImageLoaded = false; let viewState = { zoom: 1, panX: 0, panY: 0, rotation: 0, flipH: false, flipV: false }; let filters = { brightness: 100, contrast: 100, saturate: 100, hue: 0 }; let isPanning = false, panStart = { x: 0, y: 0 }; let activeTool = null, cropRect = null; let isDraggingCrop = false; let resizeObserver = null;
                    const draw = () => { if (!isImageLoaded || !currentImageBitmap) return; const canvasWidth = mainCanvas.width; const canvasHeight = mainCanvas.height; mainCtx.save(); mainCtx.fillStyle = getComputedStyle(contentArea).getPropertyValue('--image-viewer-img-bg').trim(); mainCtx.fillRect(0, 0, canvasWidth, canvasHeight); mainCtx.translate(viewState.panX, viewState.panY); mainCtx.scale(viewState.zoom, viewState.zoom); mainCtx.translate(currentImageBitmap.width / 2, currentImageBitmap.height / 2); mainCtx.rotate(viewState.rotation * Math.PI / 180); mainCtx.scale(viewState.flipH ? -1 : 1, viewState.flipV ? -1 : 1); mainCtx.translate(-currentImageBitmap.width / 2, -currentImageBitmap.height / 2); mainCtx.filter = `brightness(${filters.brightness}%) contrast(${filters.contrast}%) saturate(${filters.saturate}%) hue-rotate(${filters.hue}deg)`; mainCtx.drawImage(currentImageBitmap, 0, 0); mainCtx.restore(); };
                    const updateUI = () => { const controls = [saveBtn, zoomInBtn, zoomOutBtn, zoomSlider, fitBtn, actualBtn, toggleEditBtn, editToolbar]; controls.forEach(el => el.disabled = !isImageLoaded); if (!isImageLoaded) { placeholder.style.display = 'block'; mainCanvas.style.display = 'none'; overlayCanvas.style.display = 'none'; zoomDisplay.textContent = '--%'; editToolbar.style.display = 'none'; toggleEditBtn.classList.remove('active'); return; } placeholder.style.display = 'none'; mainCanvas.style.display = 'block'; overlayCanvas.style.display = 'block'; zoomDisplay.textContent = `${Math.round(viewState.zoom * 100)}%`; zoomSlider.value = viewState.zoom; zoomInBtn.disabled = viewState.zoom >= 10; zoomOutBtn.disabled = viewState.zoom <= 0.1; };
                    const resizeAll = () => { const rect = contentArea.getBoundingClientRect(); mainCanvas.width = rect.width; mainCanvas.height = rect.height; overlayCanvas.width = rect.width; overlayCanvas.height = rect.height; fitToWindow(); };
                    const resetView = (fit = true) => { viewState = { zoom: 1, panX: 0, panY: 0, rotation: 0, flipH: false, flipV: false }; if (fit) fitToWindow(); else draw(); updateUI(); };
                    const fitToWindow = () => { if (!isImageLoaded || !currentImageBitmap || currentImageBitmap.width === 0 || currentImageBitmap.height === 0) return; const { width: containerWidth, height: containerHeight } = contentArea.getBoundingClientRect(); if (containerWidth === 0 || containerHeight === 0) return; const imgAspectRatio = currentImageBitmap.width / currentImageBitmap.height; const containerAspectRatio = containerWidth / containerHeight; let newZoom = (imgAspectRatio > containerAspectRatio) ? (containerWidth / currentImageBitmap.width) : (containerHeight / currentImageBitmap.height); viewState.zoom = Math.max(0.1, Math.min(10, newZoom)); viewState.panX = (containerWidth - currentImageBitmap.width * viewState.zoom) / 2; viewState.panY = (containerHeight - currentImageBitmap.height * viewState.zoom) / 2; draw(); updateUI(); };
                    const handleFileOpen = async (file) => { if (!file?.type.startsWith('image/')) { showOSAlert("Please select a valid image file.", "Invalid File"); return; } filename = file.name; const url = URL.createObjectURL(file); const img = new Image(); img.onload = async () => { try { originalImage = await createImageBitmap(img); currentImageBitmap = await createImageBitmap(img); isImageLoaded = true; resetView(true); resetFilters(); } catch(e) { console.error("Error creating ImageBitmap:", e); showOSAlert("Could not process the image. It might be in an unsupported format or corrupted.", "Image Error"); } finally { URL.revokeObjectURL(url); } }; img.onerror = () => { showOSAlert("Failed to load the image.", "Load Error"); URL.revokeObjectURL(url); }; img.src = url; };
                    openBtn.addEventListener('click', () => { imageFileInput.onchange = (e) => handleFileOpen(e.target.files?.[0]); imageFileInput.click(); });
                    saveBtn.addEventListener('click', async () => { if(!isImageLoaded) return; const newFilename = await showOSDialog({ title: 'Save Image', message: 'Save file as:', type: 'prompt', defaultValue: filename, buttons: [ { label: 'Cancel', value: null }, { label: 'Save', value: true, class: 'success' } ] }); if (newFilename === null || newFilename.trim() === '') return; const tempCanvas = document.createElement('canvas'); const tempCtx = tempCanvas.getContext('2d'); tempCanvas.width = currentImageBitmap.width; tempCanvas.height = currentImageBitmap.height; tempCtx.save(); tempCtx.translate(tempCanvas.width/2, tempCanvas.height/2); tempCtx.rotate(viewState.rotation * Math.PI / 180); tempCtx.scale(viewState.flipH ? -1 : 1, viewState.flipV ? -1 : 1); tempCtx.translate(-tempCanvas.width/2, -tempCanvas.height/2); tempCtx.filter = `brightness(${filters.brightness}%) contrast(${filters.contrast}%) saturate(${filters.saturate}%) hue-rotate(${filters.hue}deg)`; tempCtx.drawImage(currentImageBitmap, 0, 0); tempCtx.restore(); tempCanvas.toBlob((blob) => { const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = newFilename; a.click(); URL.revokeObjectURL(url); }, 'image/png'); });
                    zoomInBtn.addEventListener('click', () => { viewState.zoom = Math.min(10, viewState.zoom * 1.2); draw(); updateUI(); });
                    zoomOutBtn.addEventListener('click', () => { viewState.zoom = Math.max(0.1, viewState.zoom / 1.2); draw(); updateUI(); });
                    zoomSlider.addEventListener('input', () => { viewState.zoom = parseFloat(zoomSlider.value); draw(); updateUI(); });
                    fitBtn.addEventListener('click', fitToWindow);
                    actualBtn.addEventListener('click', () => { if (!isImageLoaded) return; const { width: containerWidth, height: containerHeight } = contentArea.getBoundingClientRect(); viewState.zoom = 1; viewState.panX = (containerWidth - currentImageBitmap.width) / 2; viewState.panY = (containerHeight - currentImageBitmap.height) / 2; draw(); updateUI(); });
                    contentArea.addEventListener('mousedown', (e) => { if (!isImageLoaded || e.button !== 0) return; if(activeTool === 'crop') { handleCropStart(e); return; } isPanning = true; panStart = { x: e.clientX, y: e.clientY, panX: viewState.panX, panY: viewState.panY }; contentArea.style.cursor = 'grabbing'; });
                    window.addEventListener('mousemove', (e) => { if(isDraggingCrop) { handleCropMove(e); return; } if (isPanning) { viewState.panX = panStart.panX + (e.clientX - panStart.x); viewState.panY = panStart.panY + (e.clientY - panStart.y); draw(); } });
                    window.addEventListener('mouseup', () => { if (isDraggingCrop) { handleCropEnd(); } if (isPanning) { isPanning = false; contentArea.style.cursor = 'grab'; } });
                    toggleEditBtn.addEventListener('click', () => { const isEditing = editToolbar.style.display !== 'none'; if (isEditing) { deactivateAllTools(); editToolbar.style.display = 'none'; toggleEditBtn.classList.remove('active'); } else { editToolbar.style.display = 'flex'; toggleEditBtn.classList.add('active'); } });
                    function deactivateAllTools() { filterControls.style.display = 'none'; contextualToolbar.style.display = 'none'; if (activeTool) { const oldBtn = editToolbar.querySelector(`[data-tool="${activeTool}"]`); if (oldBtn) oldBtn.classList.remove('active'); activeTool = null; } isDraggingCrop = false; contentArea.style.cursor = 'grab'; overlayCtx.clearRect(0,0,overlayCanvas.width, overlayCanvas.height); }
                    function applyPermanentChanges(newBitmap) { currentImageBitmap = newBitmap; originalImage = newBitmap; resetView(false); fitToWindow(); deactivateAllTools(); }
                    editToolbar.addEventListener('click', async (e) => { const button = e.target.closest('button'); if (!button || !button.dataset.tool) return; const tool = button.dataset.tool; deactivateAllTools(); button.classList.add('active'); activeTool = tool; switch (tool) { case 'rotate-left': viewState.rotation = (viewState.rotation - 90) % 360; draw(); break; case 'rotate-right': viewState.rotation = (viewState.rotation + 90) % 360; draw(); break; case 'flip-h': viewState.flipH = !viewState.flipH; draw(); break; case 'flip-v': viewState.flipV = !viewState.flipV; draw(); break; case 'filters': filterControls.style.display = 'flex'; break; case 'reset': currentImageBitmap = await createImageBitmap(originalImage); resetView(true); resetFilters(); break; case 'crop': contentArea.style.cursor = 'crosshair'; showContextualToolbar([{label: 'Apply', action: applyCrop}, {label: 'Cancel', action: deactivateAllTools}]); break; case 'resize': const w = await showOSPrompt('New width:', 'Resize Image', currentImageBitmap.width); if(w === null) break; const h = await showOSPrompt('New height:', 'Resize Image', currentImageBitmap.height); if(h === null) break; const newWidth = parseInt(w), newHeight = parseInt(h); if (isNaN(newWidth) || isNaN(newHeight) || newWidth <= 0 || newHeight <= 0) { showOSAlert('Invalid dimensions provided.', 'Resize Error'); break; } const tempCanvas = document.createElement('canvas'); tempCanvas.width = newWidth; tempCanvas.height = newHeight; tempCanvas.getContext('2d').drawImage(currentImageBitmap, 0, 0, newWidth, newHeight); applyPermanentChanges(await createImageBitmap(tempCanvas)); break; } if (!['filters', 'crop'].includes(tool)) { button.classList.remove('active'); activeTool = null; } });
                    function applyFilters() { draw(); }
                    function resetFilters() { filters = { brightness: 100, contrast: 100, saturate: 100, hue: 0 }; filterControls.querySelectorAll('input[type="range"]').forEach(input => { if(input.id.includes('hue')) input.value = 0; else input.value = 100; input.dispatchEvent(new Event('input')); }); applyFilters(); }
                    filterControls.addEventListener('input', (e) => { const type = e.target.id.split('-')[1]; const value = e.target.value; filters[type] = value; contentEl.querySelector(`#iv-${type}-val-${windowId}`).textContent = type === 'hue' ? `${value}°` : `${value}%`; applyFilters(); });
                    function showContextualToolbar(buttons) { contextualToolbar.innerHTML = ''; buttons.forEach(btn => { const button = document.createElement('button'); button.textContent = btn.label; button.onclick = btn.action; contextualToolbar.appendChild(button); }); contextualToolbar.style.display = 'flex'; }
                    function handleCropStart(e) { isDraggingCrop = true; const rect = contentArea.getBoundingClientRect(); cropRect = { startX: e.clientX - rect.left, startY: e.clientY - rect.top, endX: e.clientX - rect.left, endY: e.clientY - rect.top }; }
                    function handleCropMove(e) { if(!isDraggingCrop || !cropRect) return; const rect = contentArea.getBoundingClientRect(); cropRect.endX = e.clientX - rect.left; cropRect.endY = e.clientY - rect.top; overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height); overlayCtx.fillStyle = 'rgba(0,0,0,0.5)'; overlayCtx.fillRect(0, 0, overlayCanvas.width, overlayCanvas.height); const x = Math.min(cropRect.startX, cropRect.endX); const y = Math.min(cropRect.startY, cropRect.endY); const w = Math.abs(cropRect.startX - cropRect.endX); const h = Math.abs(cropRect.startY - cropRect.endY); overlayCtx.clearRect(x,y,w,h); overlayCtx.strokeStyle = 'rgba(255,255,255,0.8)'; overlayCtx.lineWidth = 1; overlayCtx.strokeRect(x,y,w,h); }
                    function handleCropEnd() { isDraggingCrop = false; }
                    async function applyCrop() { if (!cropRect || !isImageLoaded) return; const cropX = Math.min(cropRect.startX, cropRect.endX); const cropY = Math.min(cropRect.startY, cropRect.endY); const cropW = Math.abs(cropRect.startX - cropRect.endX); const cropH = Math.abs(cropRect.startY - cropRect.endY); if (cropW < 1 || cropH < 1) { deactivateAllTools(); return; } const finalCropCanvas = document.createElement('canvas'); finalCropCanvas.width = cropW; finalCropCanvas.height = cropH; const ctx = finalCropCanvas.getContext('2d'); ctx.translate(-cropX, -cropY); ctx.translate(viewState.panX, viewState.panY); ctx.scale(viewState.zoom, viewState.zoom); ctx.translate(currentImageBitmap.width / 2, currentImageBitmap.height / 2); ctx.rotate(viewState.rotation * Math.PI / 180); ctx.scale(viewState.flipH ? -1 : 1, viewState.flipV ? -1 : 1); ctx.translate(-currentImageBitmap.width / 2, -currentImageBitmap.height / 2); ctx.filter = `brightness(${filters.brightness}%) contrast(${filters.contrast}%) saturate(${filters.saturate}%) hue-rotate(${filters.hue}deg)`; ctx.drawImage(currentImageBitmap, 0, 0); try { const newCroppedBitmap = await createImageBitmap(finalCropCanvas); applyPermanentChanges(newCroppedBitmap); } catch (e) { console.error("Error creating cropped bitmap:", e); showOSAlert("Could not apply crop. The resulting image might be empty or too complex.", "Crop Error"); } finally { cropRect = null; } }
                    if (typeof ResizeObserver !== 'undefined') { resizeObserver = new ResizeObserver(resizeAll); resizeObserver.observe(contentArea); }
                    if (openWindows[windowId]) { openWindows[windowId].cleanup = () => { if (resizeObserver) resizeObserver.disconnect(); }; }
                    updateUI();
                 } },
				 
				 
				 //PART 2
				 

                <!-- -----------------------------------------------------------------------------
                <!-- --- MediaPlayer App (FINAL - YouTube & Visualizers Fixed) ---
                <!-- -----------------------------------------------------------------------------
                'MediaPlayer': {
                    name: 'Media Player', icon: '<i class="fa-solid fa-circle-play"></i>', isCustom: false,
                    init: (contentEl, windowId) => {
                        contentEl.style.padding = '0'; contentEl.style.overflow = 'hidden';
                        const appPrefix = `media-player-${windowId}`;
                        contentEl.innerHTML = `
                        <style>
                            /* Scoped styles for the media player */
                            .${appPrefix}-app-container { display: flex; flex-direction: row; height: 100%; overflow: hidden; }
                            .${appPrefix}-main { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; min-width: 0; }
                            .${appPrefix}-playlist-container { width: 220px; flex-shrink: 0; background-color: var(--bg-primary); border-left: 1px solid var(--border-primary); display: flex; flex-direction: column; transition: width 0.3s ease-in-out, padding 0.3s ease-in-out, border-width 0.3s ease-in-out; overflow: hidden; }
                            .${appPrefix}-app-container.playlist-collapsed .${appPrefix}-playlist-container { width: 0; padding: 0; border-left-width: 0; }
                            .${appPrefix}-playlist-header { padding: 8px; font-weight: bold; border-bottom: 1px solid var(--border-primary); background-color: var(--bg-tertiary); display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; white-space: nowrap; }
                            .${appPrefix}-playlist-header button { background: none; border: none; color: var(--text-primary); cursor: pointer; padding: 2px 5px; border-radius: 3px; font-size: 0.9em; }
                            .${appPrefix}-playlist-header button:hover { background-color: var(--border-primary); }
                            .${appPrefix}-playlist { list-style: none; margin: 0; padding: 5px; overflow-y: auto; flex-grow: 1; }
                            .${appPrefix}-playlist li { padding: 6px 8px; font-size: 0.85em; border-radius: 3px; cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; border-bottom: 1px solid var(--border-secondary); }
                            .${appPrefix}-playlist li:hover { background-color: var(--taskbar-button-hover); }
                            .${appPrefix}-playlist li.active { background-color: var(--accent-primary); color: var(--text-secondary); font-weight: bold; }
                            .media-area iframe { width: 100%; height: 100%; border: none; background-color: #000; }
                            .media-controls { display: flex; align-items: center; gap: 8px; }
                            .media-controls .file-info { flex-grow: 1; text-align: left; }
                            #${appPrefix}-toggle-playlist-btn { margin-left: auto; }
                            .media-player-custom-controls button.active { color: var(--accent-primary); }
                            .visualizer-canvas { cursor: pointer; }
                        </style>
                        <div class="media-player-app ${appPrefix}-app-container playlist-collapsed" id="${appPrefix}-app-container">
                            <div class="${appPrefix}-main">
                                <div class="media-controls">
                                    <button id="${appPrefix}-open-file" title="Open and play files (replaces playlist)"><i class="fa-solid fa-folder-open"></i> Play...</button>
                                    <button id="${appPrefix}-add-files" title="Add files to playlist"><i class="fa-solid fa-plus"></i> Add...</button>
                                    <button id="${appPrefix}-open-url" title="Open from URL"><i class="fa-solid fa-link"></i> URL...</button>
                                    <span class="file-info" id="${appPrefix}-file-info">No file</span>
                                    <button id="${appPrefix}-toggle-playlist-btn" title="Show Playlist"><i class="fa-solid fa-chevron-left"></i></button>
                                </div>
                                <div class="media-area">
                                    <canvas id="${appPrefix}-visualizer" class="visualizer-canvas" title="Click to change visualizer" style="display:none;"></canvas>
                                    <video id="${appPrefix}-player" crossorigin="anonymous" style="display:none;"></video>
                                    <iframe id="${appPrefix}-youtube-player" style="display:none;" allow="fullscreen; autoplay; encrypted-media; picture-in-picture"></iframe>
                                    <span id="${appPrefix}-placeholder" class="placeholder-text">MEDIA PLAYER</span>
                                </div>
                                <div class="media-player-custom-controls" id="${appPrefix}-controls-bar">
                                    <button id="${appPrefix}-playpause"><i class="fa-solid fa-play"></i></button>
                                    <input type="range" id="${appPrefix}-progress" class="progress-bar" value="0" step="0.1">
                                    <span id="${appPrefix}-time" class="time-display">0:00 / 0:00</span>
                                    <div class="volume-control">
                                        <button id="${appPrefix}-volbtn"><i class="fa-solid fa-volume-high fa-fw"></i></button>
                                        <input type="range" id="${appPrefix}-volslider" class="volume-slider" min="0" max="1" step="0.05" value="1">
                                    </div>
                                    <button id="${appPrefix}-shuffle" title="Shuffle"><i class="fa-solid fa-shuffle"></i></button>
                                    <button id="${appPrefix}-repeat" title="No Repeat"><i class="fa-solid fa-repeat"></i></button>
                                    <button id="${appPrefix}-fullscreen" title="Enter Fullscreen" disabled><i class="fa-solid fa-expand"></i></button>
                                </div>
                            </div>
                            <div class="${appPrefix}-playlist-container">
                                <div class="${appPrefix}-playlist-header">
                                    <span>Playlist</span>
                                    <button id="${appPrefix}-clear-playlist" title="Clear Playlist"><i class="fa-solid fa-trash-can"></i></button>
                                </div>
                                <ul class="${appPrefix}-playlist" id="${appPrefix}-playlist-ul"></ul>
                            </div>
                        </div>`;

                        // --- State Variables ---
                        let playlist = []; let currentIndex = -1; let repeatMode = 'none'; let isShuffled = false;
                        let originalOrderIndices = []; let audioCtx = null, analyser = null, sourceNode = null;
                        let frequencyDataArray, timeDomainDataArray;
                        let animationFrameId = null; let youtubeWarningShown = false; let playWhenReady = false;
                        const visualizers = ['bars', 'wave', 'circle']; let currentVisualizerIndex = 0;

                        // --- Element References ---
                        const appContainer = contentEl.querySelector(`#${appPrefix}-app-container`); const mediaArea = contentEl.querySelector('.media-area');
                        const mediaElement = contentEl.querySelector(`#${appPrefix}-player`); const youtubeIframe = contentEl.querySelector(`#${appPrefix}-youtube-player`);
                        const openFileBtn = contentEl.querySelector(`#${appPrefix}-open-file`);
                        const addFilesBtn = contentEl.querySelector(`#${appPrefix}-add-files`);
                        const openUrlBtn = contentEl.querySelector(`#${appPrefix}-open-url`);
                        const fileInfoSpan = contentEl.querySelector(`#${appPrefix}-file-info`); const placeholderText = contentEl.querySelector(`#${appPrefix}-placeholder`);
                        const canvas = contentEl.querySelector(`#${appPrefix}-visualizer`); const canvasCtx = canvas.getContext('2d');
                        const controlsBar = contentEl.querySelector(`#${appPrefix}-controls-bar`); const playPauseBtn = contentEl.querySelector(`#${appPrefix}-playpause`);
                        const progressBar = contentEl.querySelector(`#${appPrefix}-progress`); const timeDisplay = contentEl.querySelector(`#${appPrefix}-time`);
                        const volumeBtn = contentEl.querySelector(`#${appPrefix}-volbtn`); const volumeSlider = contentEl.querySelector(`#${appPrefix}-volslider`);
                        const shuffleBtn = contentEl.querySelector(`#${appPrefix}-shuffle`); const repeatBtn = contentEl.querySelector(`#${appPrefix}-repeat`);
                        const fullscreenBtn = contentEl.querySelector(`#${appPrefix}-fullscreen`); const playlistUl = contentEl.querySelector(`#${appPrefix}-playlist-ul`);
                        const togglePlaylistBtn = contentEl.querySelector(`#${appPrefix}-toggle-playlist-btn`); const clearPlaylistBtn = contentEl.querySelector(`#${appPrefix}-clear-playlist`);

                        const getYouTubeVideoId = (url) => { const regex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/|v\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})/; const match = url.match(regex); return match ? match[1] : null; };
                        
                        // --- Core Functions ---
                        const renderPlaylist = () => { playlistUl.innerHTML = ''; if (playlist.length === 0) { playlistUl.innerHTML = `<li style="text-align:center; font-style:italic; cursor:default; color:grey;">Empty</li>`; return; } const indicesOrder = isShuffled ? originalOrderIndices : playlist.map((_, i) => i); indicesOrder.forEach((originalIndex) => { const item = playlist[originalIndex]; const li = document.createElement('li'); li.textContent = item.name; li.title = item.name; li.dataset.index = originalIndex; if (originalIndex === currentIndex) li.classList.add('active'); li.addEventListener('click', () => playTrack(parseInt(li.dataset.index), true)); playlistUl.appendChild(li); }); };
                        
                        const playTrack = async (index, forcePlay = false) => {
                            if (index < 0 || index >= playlist.length) { resetMediaPlayerState(false); return; }
                            playWhenReady = forcePlay; currentIndex = index; const track = playlist[currentIndex];
                            
                            const videoId = getYouTubeVideoId(track.url);

                            if (videoId) {
                                stopVisualizer();
                                mediaElement.pause();
                            } else {
                                youtubeIframe.src = 'about:blank';
                            }
                            
                            youtubeIframe.style.display = 'none';
                            mediaElement.style.display = 'none';
                            canvas.style.display = 'none';
                            placeholderText.style.display = 'none';
                            controlsBar.style.display = 'flex';
                            
                            fileInfoSpan.textContent = track.name;
                            renderPlaylist(); updatePlayButton(); fullscreenBtn.disabled = false;
                            
                            if (videoId) {
                                if (!youtubeWarningShown) { await showOSAlert("Playing a YouTube video.\n\nNote: Custom controls are disabled for YouTube playback. Use the native player controls.", "YouTube Playback"); youtubeWarningShown = true; }
                                controlsBar.style.display = 'none';
                                youtubeIframe.src = `https://www.youtube.com/embed/${videoId}?autoplay=1&rel=0`;
                                youtubeIframe.style.display = 'block';
                            } else {
                                if (track.isUrl) { placeholderText.textContent = 'Loading web media...'; placeholderText.style.display = 'flex'; }
                                mediaElement.src = track.url;
                                mediaElement.load();
                            }
                        };
                        
                        const handleNextTrack = () => { if (playlist.length === 0) return; if (repeatMode === 'one') { mediaElement.currentTime = 0; mediaElement.play(); return; } let nextIndex = isShuffled ? originalOrderIndices[(originalOrderIndices.indexOf(currentIndex) + 1) % playlist.length] : currentIndex + 1; if (nextIndex >= playlist.length) { if (repeatMode === 'all') nextIndex = isShuffled ? originalOrderIndices[0] : 0; else { mediaElement.pause(); mediaElement.currentTime = 0; updatePlayButton(); return; } } playTrack(nextIndex, true); };
                        const resetMediaPlayerState = (clearPlaylist = true) => { stopVisualizer(); mediaElement.pause(); youtubeIframe.src = 'about:blank'; if (sourceNode) { sourceNode.disconnect(); sourceNode = null; } if (clearPlaylist) { playlist.forEach(item => { if (item.url && item.url.startsWith('blob:')) { URL.revokeObjectURL(item.url); } }); playlist = []; currentIndex = -1; isShuffled = false; originalOrderIndices = []; toggleShuffle(false); } mediaElement.removeAttribute('src'); mediaElement.load(); fileInfoSpan.textContent = "No file"; placeholderText.style.display = 'flex'; placeholderText.textContent = 'MEDIA PLAYER'; mediaElement.style.display = 'none'; youtubeIframe.style.display = 'none'; canvas.style.display = 'none'; controlsBar.style.display = 'flex'; updatePlayButton(); progressBar.value = 0; updateProgress(); renderPlaylist(); fullscreenBtn.disabled = true; updateFullscreenButton(); };
                        
                        const handleFileSelect = (event) => {
                            const files = event.target.files;
                            if (!files || files.length === 0) return;
                            resetMediaPlayerState(true);
                            for (const file of files) {
                                playlist.push({ name: file.name, type: file.type, url: URL.createObjectURL(file), isUrl: false });
                            }
                            renderPlaylist();
                            if (playlist.length > 0) {
                                playTrack(0, true);
                            }
                            mediaFileInput.value = null;
                            mediaFileInput.onchange = null;
                        };

                        const handleAddFilesOnly = (event) => { const files = event.target.files; if (!files || files.length === 0) return; const startIndexForNewFiles = playlist.length; for (const file of files) playlist.push({ name: file.name, type: file.type, url: URL.createObjectURL(file), isUrl: false }); if (isShuffled) toggleShuffle(true); renderPlaylist(); if (playlist.length > startIndexForNewFiles) playTrack(startIndexForNewFiles, true); mediaFileInput.value = null; mediaFileInput.onchange = null; };
                        const handleUrlSelect = async () => { const url = await showOSPrompt("Enter a direct video/audio URL or a YouTube link:", "Open URL", "https://"); if (!url || !(url.startsWith('http') || url.startsWith('www.'))) { if(url) showOSAlert("Invalid URL.", "Error"); return; } const trackName = getYouTubeVideoId(url) ? "YouTube Stream" : (url.split('/').pop().split('?')[0] || "Remote Stream"); playlist.push({ name: trackName, type: 'video/remote', url: url, isUrl: true }); if (isShuffled) toggleShuffle(true); playTrack(playlist.length - 1, true); };
                        const toggleShuffle = (forceOn = null) => { isShuffled = forceOn !== null ? forceOn : !isShuffled; shuffleBtn.classList.toggle('active', isShuffled); shuffleBtn.title = isShuffled ? 'Disable Shuffle' : 'Enable Shuffle'; if (isShuffled) { originalOrderIndices = [...Array(playlist.length).keys()]; for (let i = originalOrderIndices.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [originalOrderIndices[i], originalOrderIndices[j]] = [originalOrderIndices[j], originalOrderIndices[i]]; } } else { originalOrderIndices = []; } renderPlaylist(); };
                        const toggleFullScreen = () => { if (!document.fullscreenElement) { mediaArea.requestFullscreen().catch(err => console.error(`Fullscreen error: ${err.message}`)); } else { document.exitFullscreen(); } };
                        const updateFullscreenButton = () => { const isInFullscreen = !!document.fullscreenElement; fullscreenBtn.innerHTML = isInFullscreen ? '<i class="fa-solid fa-compress"></i>' : '<i class="fa-solid fa-expand"></i>'; fullscreenBtn.title = isInFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen'; };
                        const togglePlaylistVisibility = () => { appContainer.classList.toggle('playlist-collapsed'); const isCollapsed = appContainer.classList.contains('playlist-collapsed'); togglePlaylistBtn.innerHTML = isCollapsed ? `<i class="fa-solid fa-chevron-left"></i>` : `<i class="fa-solid fa-chevron-right"></i>`; togglePlaylistBtn.title = isCollapsed ? 'Show Playlist' : 'Hide Playlist'; };
                        function formatTime(seconds) { if (isNaN(seconds) || !isFinite(seconds)) return "0:00"; const min = Math.floor(seconds / 60); const sec = Math.floor(seconds % 60); return `${min}:${sec < 10 ? '0' : ''}${sec}`; }
                        function updateProgress() { const duration = mediaElement.duration; const currentTime = mediaElement.currentTime; let percentage = 0; if (!isNaN(duration) && isFinite(duration) && duration > 0) percentage = (currentTime / duration) * 100; progressBar.value = isNaN(percentage) ? 0 : percentage; progressBar.style.background = `linear-gradient(to right, var(--accent-primary) ${percentage}%, var(--bg-primary) ${percentage}%)`; timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`; }
                        function setProgress() { const duration = mediaElement.duration; if (isNaN(duration) || !isFinite(duration) || duration <= 0) return; mediaElement.currentTime = isFinite((progressBar.value / 100) * duration) ? (progressBar.value / 100) * duration : 0; updateProgress(); }
                        function togglePlay() { if (youtubeIframe.style.display === 'block') { youtubeIframe.contentWindow.postMessage('{"event":"command","func":"' + (mediaElement.paused ? 'playVideo' : 'pauseVideo') + '","args":""}', '*'); return; } if (!mediaElement.src) return; if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); if (mediaElement.paused || mediaElement.ended) { mediaElement.play().catch(e => console.error("Play error:", e)); } else { mediaElement.pause(); } }
                        function updatePlayButton() { playPauseBtn.innerHTML = (mediaElement.paused || mediaElement.ended) ? '<i class="fa-solid fa-play"></i>' : '<i class="fa-solid fa-pause"></i>'; }
                        function toggleMute() { mediaElement.muted = !mediaElement.muted; updateVolumeIcon(); }
                        function updateVolumeIcon() { let iconClass = (mediaElement.muted || mediaElement.volume === 0) ? 'fa-volume-xmark' : (mediaElement.volume < 0.5) ? 'fa-volume-low' : 'fa-volume-high'; volumeBtn.innerHTML = `<i class="fa-solid ${iconClass} fa-fw"></i>`; }
                        function setVolume() { mediaElement.volume = volumeSlider.value; mediaElement.muted = parseFloat(mediaElement.volume) === 0; updateVolumeIcon(); }
                        const handleClearPlaylist = async () => { if (playlist.length === 0) return; if(await showOSConfirmDanger("Are you sure you want to clear the entire playlist?", "Clear Playlist")) { resetMediaPlayerState(true); } };

                        // --- Visualizer Functions ---
                        function setupAudioContext() { if (audioCtx && audioCtx.state !== 'closed') return; try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); analyser = audioCtx.createAnalyser(); analyser.fftSize = 256; frequencyDataArray = new Uint8Array(analyser.frequencyBinCount); timeDomainDataArray = new Uint8Array(analyser.frequencyBinCount); } catch (e) { console.error("AudioContext not supported:", e); audioCtx = null; analyser = null; } }
                        function connectSourceNode() { if (!audioCtx || !analyser || !mediaElement.src || sourceNode || audioCtx.state === 'closed') return; try { sourceNode = audioCtx.createMediaElementSource(mediaElement); sourceNode.connect(analyser); analyser.connect(audioCtx.destination); startVisualizer(); } catch (e) { console.error("Error connecting MediaElementSource (this can happen on file:// URIs, visualizer disabled):", e); sourceNode = null; } }
                        function drawBars() { const bufferLength = analyser.frequencyBinCount; const barWidth = (canvas.width / bufferLength) * 1.5; let x = 0; const barColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim() || '#0078d4'; for (let i = 0; i < bufferLength; i++) { const barHeight = frequencyDataArray[i] / 2; canvasCtx.fillStyle = barColor; canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight); x += barWidth + 1; } }
                        function drawWave() { const bufferLength = analyser.frequencyBinCount; canvasCtx.lineWidth = 2; canvasCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim() || '#0078d4'; canvasCtx.beginPath(); const sliceWidth = canvas.width * 1.0 / bufferLength; let x = 0; for (let i = 0; i < bufferLength; i++) { const v = timeDomainDataArray[i] / 128.0; const y = v * canvas.height / 2; if (i === 0) { canvasCtx.moveTo(x, y); } else { canvasCtx.lineTo(x, y); } x += sliceWidth; } canvasCtx.lineTo(canvas.width, canvas.height / 2); canvasCtx.stroke(); }
                        function drawCircle() { const bufferLength = analyser.frequencyBinCount; const centerX = canvas.width / 2; const centerY = canvas.height / 2; const radius = Math.min(centerX, centerY) * 0.4; const barColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim() || '#0078d4'; canvasCtx.strokeStyle = barColor; canvasCtx.lineWidth = 2; for (let i = 0; i < bufferLength; i++) { const barHeight = frequencyDataArray[i] / 2 * 0.8; const angle = (i / bufferLength) * 2 * Math.PI; const x1 = centerX + Math.cos(angle) * radius; const y1 = centerY + Math.sin(angle) * radius; const x2 = centerX + Math.cos(angle) * (radius + barHeight); const y2 = centerY + Math.sin(angle) * (radius + barHeight); canvasCtx.beginPath(); canvasCtx.moveTo(x1, y1); canvasCtx.lineTo(x2, y2); canvasCtx.stroke(); } }
                        function drawVisualizer() { if (!audioCtx || !analyser || canvas.style.display === 'none' || audioCtx.state === 'closed' || !sourceNode) { stopVisualizer(); return; } animationFrameId = requestAnimationFrame(drawVisualizer); analyser.getByteFrequencyData(frequencyDataArray); analyser.getByteTimeDomainData(timeDomainDataArray); canvasCtx.fillStyle = getComputedStyle(canvas).getPropertyValue('--media-player-video-bg') || '#000'; canvasCtx.fillRect(0, 0, canvas.width, canvas.height); switch (visualizers[currentVisualizerIndex]) { case 'wave': drawWave(); break; case 'circle': drawCircle(); break; case 'bars': default: drawBars(); break; } }
                        function startVisualizer() { if (animationFrameId || !sourceNode) return; canvas.width = canvas.clientWidth || 300; canvas.height = canvas.clientHeight || 150; drawVisualizer(); }
                        function stopVisualizer() { if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } }

                        // --- Event Listeners ---
                        openFileBtn.addEventListener('click', () => { mediaFileInput.multiple = true; mediaFileInput.onchange = handleFileSelect; mediaFileInput.click(); });
                        addFilesBtn.addEventListener('click', () => { mediaFileInput.multiple = true; mediaFileInput.onchange = handleAddFilesOnly; mediaFileInput.click(); });
                        openUrlBtn.addEventListener('click', handleUrlSelect);
                        mediaElement.addEventListener('canplay', () => { placeholderText.style.display = 'none'; const currentTrack = playlist[currentIndex]; if (currentTrack && currentTrack.type.startsWith('audio/') && !currentTrack.isUrl) { canvas.style.display = 'block'; mediaElement.style.display = 'none'; setupAudioContext(); } else { canvas.style.display = 'none'; mediaElement.style.display = 'block'; } if (playWhenReady) { mediaElement.play().catch(e => console.error("Play on canplay failed:", e)); playWhenReady = false; } });
                        mediaElement.addEventListener('error', async (e) => { const trackName = playlist[currentIndex]?.name || 'the source'; if (mediaElement.src && !mediaElement.src.startsWith('blob:')) { /* Ignore spurious errors from empty src */ return; } placeholderText.textContent = 'Error: Could not load media.'; placeholderText.style.display = 'flex'; mediaElement.style.display = 'none'; canvas.style.display = 'none'; playWhenReady = false; await showOSAlert(`Failed to load the media from "${trackName}". It might be an invalid link, a CORS issue, or an unsupported format.`, "Media Load Error"); });
                        mediaElement.addEventListener('loadedmetadata', updateProgress);
                        mediaElement.addEventListener('play', () => { updatePlayButton(); if (canvas.style.display === 'block') { if (!sourceNode) connectSourceNode(); startVisualizer(); } });
                        mediaElement.addEventListener('pause', () => { updatePlayButton(); stopVisualizer(); });
                        mediaElement.addEventListener('ended', handleNextTrack);
                        mediaElement.addEventListener('timeupdate', updateProgress);
                        mediaElement.addEventListener('volumechange', updateVolumeIcon);
                        playPauseBtn.addEventListener('click', togglePlay);
                        progressBar.addEventListener('input', setProgress);
                        volumeBtn.addEventListener('click', toggleMute);
                        volumeSlider.addEventListener('input', setVolume);
                        shuffleBtn.addEventListener('click', () => toggleShuffle());
                        repeatBtn.addEventListener('click', () => { if (repeatMode === 'none') { repeatMode = 'all'; repeatBtn.classList.add('active'); repeatBtn.title = "Repeat All"; repeatBtn.innerHTML = '<i class="fa-solid fa-repeat"></i>'; } else if (repeatMode === 'all') { repeatMode = 'one'; repeatBtn.classList.add('active'); repeatBtn.title = "Repeat One"; repeatBtn.innerHTML = '<i class="fa-solid fa-1"></i>'; } else { repeatMode = 'none'; repeatBtn.classList.remove('active'); repeatBtn.title = "No Repeat"; repeatBtn.innerHTML = '<i class="fa-solid fa-repeat"></i>'; } });
                        togglePlaylistBtn.addEventListener('click', togglePlaylistVisibility);
                        clearPlaylistBtn.addEventListener('click', handleClearPlaylist);
                        fullscreenBtn.addEventListener('click', toggleFullScreen);
                        document.addEventListener('fullscreenchange', updateFullscreenButton);
                        canvas.addEventListener('click', () => { currentVisualizerIndex = (currentVisualizerIndex + 1) % visualizers.length; });
                        
                        // --- Initialization & Cleanup ---
                        updateVolumeIcon(); resetMediaPlayerState(true);
                        if (openWindows[windowId]) { openWindows[windowId].cleanup = () => { resetMediaPlayerState(true); if (audioCtx && audioCtx.state !== 'closed') { audioCtx.close(); audioCtx = null; } analyser = null; document.removeEventListener('fullscreenchange', updateFullscreenButton); }; }
                    }
                },                
				
                <!-- -----------------------------------------------------------------------------
                <!-- --- Browser App ---
                <!-- -----------------------------------------------------------------------------
                 'Browser': { name: 'Browser', icon: '<i class="fa-solid fa-globe"></i>', isCustom: false, init: (contentEl, windowId) => {
                    contentEl.style.padding = '0'; contentEl.style.overflow = 'hidden'; const iframeId = `browser-frame-${windowId}`; const urlInputId = `browser-url-${windowId}`; const goButtonId = `browser-go-${windowId}`; const backButtonId = `browser-back-${windowId}`; const forwardButtonId = `browser-forward-${windowId}`; const reloadButtonId = `browser-reload-${windowId}`; const placeholderId = `browser-placeholder-${windowId}`;
                    contentEl.innerHTML = `<div class="browser-app"><div class="browser-toolbar"><button id="${backButtonId}" title="Back" disabled><i class="fa-solid fa-arrow-left"></i></button><button id="${forwardButtonId}" title="Forward" disabled><i class="fa-solid fa-arrow-right"></i></button><button id="${reloadButtonId}" title="Reload"><i class="fa-solid fa-rotate-right"></i></button><input type="text" id="${urlInputId}" placeholder="Enter URL (e.g., https://example.com)"><button id="${goButtonId}"><i class="fa-solid fa-arrow-right"></i></button></div>
                    <div class="browser-content">
                        <div id="${placeholderId}" class="iframe-placeholder">
                            <h4><i class="fa-solid fa-triangle-exclamation"></i> Browser Warning</h4>
                            <p>This browser has <strong>limited capabilities</strong> and may not render all websites correctly. Many modern websites employ security measures (like X-Frame-Options) that <strong>prevent them from being embedded in iframes</strong> like this.</p>
                            <p><strong>Do NOT use this browser for accessing sensitive information, logging into accounts (e.g., Google, banking), or any critical tasks.</strong></p>
                            <p>It is provided as a basic tool for simple browsing. Use at your own risk.</p>
                            <p style="margin-top:15px;"><em>Enter a URL above to attempt loading a page.</em></p>
                        </div>
                        <iframe id="${iframeId}" sandbox="allow-scripts allow-same-origin allow-popups allow-forms" referrerpolicy="no-referrer"></iframe>
                    </div></div>`;
                    const iframe = contentEl.querySelector(`#${iframeId}`); const urlInput = contentEl.querySelector(`#${urlInputId}`); const goButton = contentEl.querySelector(`#${goButtonId}`); const backButton = contentEl.querySelector(`#${backButtonId}`); const forwardButton = contentEl.querySelector(`#${forwardButtonId}`); const reloadButton = contentEl.querySelector(`#${reloadButtonId}`); const placeholder = contentEl.querySelector(`#${placeholderId}`); let history = []; let historyIndex = -1; let isLoading = false;
                    function navigate(url, isHistoryNavigation = false) { if (isLoading) return; isLoading = true; placeholder.style.display = 'none'; iframe.style.display = 'none'; iframe.removeAttribute('srcdoc'); let targetUrl = url.trim(); if (!targetUrl) { isLoading = false; placeholder.style.display = 'flex'; return; } if (!targetUrl.startsWith('http://') && !targetUrl.startsWith('https://') && !targetUrl.startsWith('about:')) { if (!targetUrl.includes(':')) targetUrl = 'https://' + targetUrl; else { iframe.srcdoc = `<p style="color: red;">Error: Invalid URL scheme.</p>`; iframe.style.display = 'block'; isLoading = false; updateNavButtons(); return; } } urlInput.value = targetUrl; iframe.src = targetUrl; if (!isHistoryNavigation) { history = history.slice(0, historyIndex + 1); history.push(targetUrl); historyIndex++; } updateNavButtons(); iframe.onload = () => { iframe.style.display = 'block'; isLoading = false; try { const currentFrameUrl = iframe.contentWindow.location.href; if (currentFrameUrl && currentFrameUrl !== 'about:blank') urlInput.value = currentFrameUrl; else if (!targetUrl.startsWith('about:')) urlInput.value = targetUrl; } catch (e) { if (!targetUrl.startsWith('about:')) urlInput.value = targetUrl;} updateNavButtons(); }; iframe.onerror = () => { iframe.style.display = 'block'; iframe.srcdoc = `<p style="color: red;">Error: Could not load URL. Many sites block embedding.</p>`; isLoading = false; updateNavButtons(); }; }
                    function updateNavButtons() { backButton.disabled = historyIndex <= 0; forwardButton.disabled = historyIndex >= history.length - 1; }
                    goButton.addEventListener('click', () => navigate(urlInput.value)); urlInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') navigate(urlInput.value); }); backButton.addEventListener('click', () => { if (historyIndex > 0) { historyIndex--; navigate(history[historyIndex], true); } }); forwardButton.addEventListener('click', () => { if (historyIndex < history.length - 1) { historyIndex++; navigate(history[historyIndex], true); } }); reloadButton.addEventListener('click', () => { if (!isLoading && iframe.src && !iframe.src.startsWith('about:blank') && !iframe.srcdoc) { try { iframe.contentWindow.location.reload(); } catch(e){ iframe.src = iframe.src; }} });
                    iframe.style.display = 'none'; placeholder.style.display = 'flex'; updateNavButtons();
                    if (openWindows[windowId]) { openWindows[windowId].cleanup = () => { iframe.src = 'about:blank'; }; }
                 } },

                <!-- -----------------------------------------------------------------------------
                <!-- --- Settings App ---
                <!-- -----------------------------------------------------------------------------
                                    
								'Settings': {
    name: 'Settings',
    icon: '<i class="fa-solid fa-gear"></i>',
    isCustom: false,
    init: (contentEl, windowId) => {
        // --- 1. HTML Structure ---
        const presets = [
            { name: 'Blue', color: '#0078D4', id: 'blue' }, { name: 'Red', color: '#D32F2F', id: 'red' },
            { name: 'Green', color: '#388E3C', id: 'green' }, { name: 'Orange', color: '#F57C00', id: 'orange' },
            { name: 'Grey', color: '#424242', id: 'dark_grey' }
        ];
        let presetButtonsHTML = presets.map(p => 
            `<button data-preset="${p.id}" style="background-color: ${p.color}; color: white; text-shadow: 1px 1px 2px rgba(0,0,0,0.4);">${p.name}</button>`
        ).join('');
        
        // The theme selector dropdown and its options have been removed from here.
        
        contentEl.innerHTML = `
        <div class="settings-app">
            <div class="settings-section">
                <h3 class="settings-section-toggle">Appearance <i class="fa-solid fa-chevron-down collapse-icon"></i></h3>
                <div class="settings-section-content">
                     <!-- THEME SELECTOR DROPDOWN REMOVED FROM HERE -->
                    <div class="settings-subsection-title">Theme Presets</div>
                    <div class="settings-item">
                        <label>Quick Setup:</label>
                        <div class="controls preset-buttons" id="theme-preset-buttons-${windowId}">
                           ${presetButtonsHTML}
                        </div>
                    </div>
                    <div class="settings-subsection-title">Color Customization</div>
                    <div class="settings-item"> <label>Start Button:</label> <div class="controls"> <input type="color" id="settings-start-button-bg-${windowId}"> <button id="settings-reset-start-button-bg-${windowId}" class="reset-button" title="Reset to theme default"><i class="fa-solid fa-arrow-rotate-left"></i></button> </div> </div>
                    <div class="settings-item"> <label>Start Menu Icons:</label> <div class="controls"> <input type="color" id="settings-start-menu-icon-color-${windowId}"> <button id="settings-reset-start-menu-icon-color-${windowId}" class="reset-button" title="Reset to theme default"><i class="fa-solid fa-arrow-rotate-left"></i></button> </div> </div>
                    <div class="settings-item"> <label>Desktop Icons:</label> <div class="controls"> <input type="color" id="settings-icon-color-${windowId}"> <button id="settings-reset-icon-color-${windowId}" class="reset-button" title="Reset to theme default"><i class="fa-solid fa-arrow-rotate-left"></i></button> </div> </div>
                    <div class="settings-item"> <label>Active Window Border:</label> <div class="controls"> <input type="color" id="settings-window-active-border-color-${windowId}"> <button id="settings-reset-window-active-border-color-${windowId}" class="reset-button" title="Reset to theme default"><i class="fa-solid fa-arrow-rotate-left"></i></button> </div> </div>
                    <div class="settings-subsection-title">Taskbar</div>
                    <div class="settings-item"> <label>Taskbar Color:</label> <div class="controls"> <input type="color" id="settings-taskbar-color-${windowId}"> <button id="settings-reset-taskbar-color-${windowId}" class="reset-button" title="Reset to theme default"><i class="fa-solid fa-arrow-rotate-left"></i></button> </div> </div>
                </div>
            </div>

            <div class="settings-section">
                <h3 class="settings-section-toggle">Desktop Background <i class="fa-solid fa-chevron-down collapse-icon"></i></h3>
                <div class="settings-section-content">
                    <div class="settings-item"> <label>Gradient:</label> <div class="controls"> <label>Top:</label><input type="color" id="settings-bg-color1-${windowId}"> <label>Bottom:</label><input type="color" id="settings-bg-color2-${windowId}"> <button id="settings-apply-gradient-${windowId}">Apply Gradient</button> </div> </div>
                    <div class="settings-item"> <label>Custom Image:</label> <div class="controls"> <button id="settings-wallpaper-btn-${windowId}"><i class="fa-solid fa-image"></i> Choose File...</button> <button id="settings-clear-wallpaper-${windowId}"><i class="fa-solid fa-ban"></i> Clear Background</button> </div> </div>
                    <div class="settings-subsection-title" style="margin-top: 15px;">Default Wallpapers</div>
                    <div class="wallpaper-selector-container"> <div class="wallpaper-selector" id="wallpaper-selector-${windowId}"></div> </div>
                </div>
            </div>

            <div class="settings-section">
                <h3 class="settings-section-toggle">Custom Stylesheet <i class="fa-solid fa-chevron-down collapse-icon"></i></h3>
                <div class="settings-section-content">
                    <div class="settings-item"> <label>Load Custom CSS:</label> <div class="controls"> <button id="settings-trigger-custom-css-file-${windowId}"><i class="fa-solid fa-upload"></i> Choose .css File...</button> </div> </div>
                    <div class="settings-item"> <label>Current Custom CSS:</label> <div class="controls"> <span id="settings-custom-css-filename-${windowId}" style="margin-right:10px; font-style:italic;">None</span> <button id="settings-apply-custom-css-${windowId}" disabled title="Apply chosen CSS file"><i class="fa-solid fa-check"></i> Apply</button> <button id="settings-clear-custom-css-${windowId}" title="Clear custom CSS and revert to default theme" disabled><i class="fa-solid fa-times"></i> Clear</button> </div> </div>
                    <div class="settings-item status-message" id="settings-css-status-${windowId}" style="font-size: 0.9em; margin-top: 5px;"></div>
                </div>
            </div>

            <div class="settings-section">
                 <h3 class="settings-section-toggle">UI Behavior <i class="fa-solid fa-chevron-down collapse-icon"></i></h3>
                 <div class="settings-section-content">
                    <div class="settings-item"> <label>Start Menu View:</label> <div class="controls"> <label><input type="radio" name="startmenu-view-${windowId}" value="list" id="startmenu-view-list-${windowId}"> List</label> <label><input type="radio" name="startmenu-view-${windowId}" value="grid" id="startmenu-view-grid-${windowId}"> Grid</label> </div> </div>
                    <div class="settings-item"> <label for="settings-disable-animations-${windowId}">Disable Animations:</label> <div class="controls"> <input type="checkbox" id="settings-disable-animations-${windowId}"> </div> </div>
                    <div class="settings-item"> <label for="settings-enable-context-menu-${windowId}">Enable Custom Context Menu:</label> <div class="controls"> <input type="checkbox" id="settings-enable-context-menu-${windowId}"> </div> </div>
                    <div class="settings-item"> <label for="settings-window-glow-enable-${windowId}">Active Window Blink Glow:</label> <div class="controls"> <input type="checkbox" id="settings-window-glow-enable-${windowId}"> </div> </div>
                    <div class="settings-item"> <label for="settings-window-glow-speed-${windowId}">Window Glow Speed (s):</label> <div class="controls"> <input type="range" id="settings-window-glow-speed-${windowId}" min="0.5" max="5" step="0.1" value="1.5" style="flex-grow:1;"> <span id="settings-window-glow-speed-value-${windowId}" style="min-width:35px; text-align:right;">1.5s</span> </div> </div>
                    <div class="settings-item"> <label for="settings-start-button-glow-enable-${windowId}">Start Button Blink Glow:</label> <div class="controls"> <input type="checkbox" id="settings-start-button-glow-enable-${windowId}"> </div> </div>
                </div>
            </div>

            <div class="settings-section">
                <h3 class="settings-section-toggle">System Maintenance <i class="fa-solid fa-chevron-down collapse-icon"></i></h3>
                <div class="settings-section-content">
                    <div class="settings-item"> <label style="min-width: initial;">Clear Cache & Reset OS:</label> <div class="controls"> <button id="settings-clear-cache-reset-${windowId}" style="background-color: var(--accent-danger); color: var(--text-secondary-dark);"><i class="fa-solid fa-triangle-exclamation"></i> Clear All Data & Reset</button> </div> </div>
                    <p style="font-size:0.85em; color: var(--settings-footer-text); margin-top: 5px;"> <strong>Warning:</strong> This action is irreversible and will delete all stored settings, apps, and notes. </p>
                </div>
            </div>

            <div class="settings-section">
                <h3 class="settings-section-toggle">About Simplex OS <i class="fa-solid fa-chevron-down collapse-icon"></i></h3>
                <div class="settings-section-content">
                    <p><strong>Version:</strong> Simplex OS V1.5 (Gregory)</p> <p>Built with HTML, CSS, and JavaScript.</p>
                    <div class="settings-subsection-title">Credits</div>
                    <ul class="credits-list">
                        <li><strong>Icons:</strong> <a href="https://fontawesome.com/" target="_blank">Font Awesome</a></li>
                                            </ul>
                    <p style="margin-top:15px; font-size:0.85em; color: var(--settings-footer-text);"> Simplex OS is a conceptual project for demonstrating a web-based desktop environment. </p>
                </div>
            </div>

            <div class="settings-footer">Simplex OS created by Exanx</div>
        </div>`;
        const settingsAppEl = contentEl.querySelector('.settings-app');
        
        // --- Element References ---
        // THEME SELECTOR VARIABLE REMOVED FROM HERE
        const bgColor1Input = contentEl.querySelector(`#settings-bg-color1-${windowId}`); const bgColor2Input = contentEl.querySelector(`#settings-bg-color2-${windowId}`); const applyGradientBtn = contentEl.querySelector(`#settings-apply-gradient-${windowId}`); const wallpaperBtn = contentEl.querySelector(`#settings-wallpaper-btn-${windowId}`); const clearWallpaperBtn = contentEl.querySelector(`#settings-clear-wallpaper-${windowId}`); const startMenuViewListRadio = contentEl.querySelector(`#startmenu-view-list-${windowId}`); const startMenuViewGridRadio = contentEl.querySelector(`#startmenu-view-grid-${windowId}`); const disableAnimationsCheckbox = contentEl.querySelector(`#settings-disable-animations-${windowId}`); const wallpaperSelectorDiv = contentEl.querySelector(`#wallpaper-selector-${windowId}`);
        const iconColorInput = contentEl.querySelector(`#settings-icon-color-${windowId}`); const resetIconColorBtn = contentEl.querySelector(`#settings-reset-icon-color-${windowId}`);
        const startButtonBgInput = contentEl.querySelector(`#settings-start-button-bg-${windowId}`); const resetStartButtonBgBtn = contentEl.querySelector(`#settings-reset-start-button-bg-${windowId}`);
        const startMenuIconColorInput = contentEl.querySelector(`#settings-start-menu-icon-color-${windowId}`); const resetStartMenuIconColorBtn = contentEl.querySelector(`#settings-reset-start-menu-icon-color-${windowId}`);
        const windowActiveBorderColorInput = contentEl.querySelector(`#settings-window-active-border-color-${windowId}`); const resetWindowActiveBorderColorBtn = contentEl.querySelector(`#settings-reset-window-active-border-color-${windowId}`);
        const themePresetButtonsContainer = contentEl.querySelector(`#theme-preset-buttons-${windowId}`);
        const enableContextMenuCheckbox = contentEl.querySelector(`#settings-enable-context-menu-${windowId}`);

        const windowGlowEnableCheckbox = contentEl.querySelector(`#settings-window-glow-enable-${windowId}`);
        const windowGlowSpeedSlider = contentEl.querySelector(`#settings-window-glow-speed-${windowId}`);
        const windowGlowSpeedValueSpan = contentEl.querySelector(`#settings-window-glow-speed-value-${windowId}`);
        const startButtonGlowEnableCheckbox = contentEl.querySelector(`#settings-start-button-glow-enable-${windowId}`);
        const triggerCustomCSSFileBtn = contentEl.querySelector(`#settings-trigger-custom-css-file-${windowId}`);
        const applyCustomCSSBtn = contentEl.querySelector(`#settings-apply-custom-css-${windowId}`);
        const clearCustomCSSBtn = contentEl.querySelector(`#settings-clear-custom-css-${windowId}`);
        const customCSSFilenameSpan = contentEl.querySelector(`#settings-custom-css-filename-${windowId}`);
        const cssStatusEl = contentEl.querySelector(`#settings-css-status-${windowId}`);
        const taskbarColorInput = contentEl.querySelector(`#settings-taskbar-color-${windowId}`);
        const resetTaskbarColorBtn = contentEl.querySelector(`#settings-reset-taskbar-color-${windowId}`);
        const clearCacheResetBtn = contentEl.querySelector(`#settings-clear-cache-reset-${windowId}`);

        let chosenFileContent = null; let chosenFilename = null;

        function loadCurrentSettings() {
            // THEME SELECTOR VALUE SETTING REMOVED FROM HERE
            bgColor1Input.value=localStorage.getItem(BG_COLOR1_KEY)||DEFAULT_BG_COLOR1; bgColor2Input.value=localStorage.getItem(BG_COLOR2_KEY)||DEFAULT_BG_COLOR2;
            highlightSelectedWallpaper(); const view=localStorage.getItem(STARTMENU_VIEW_KEY)||DEFAULT_STARTMENU_VIEW; if(view==='grid')startMenuViewGridRadio.checked=true;else startMenuViewListRadio.checked=true;
            const animDisabled=localStorage.getItem(ANIMATIONS_DISABLED_KEY)==='true'; disableAnimationsCheckbox.checked=animDisabled;
            iconColorInput.value = localStorage.getItem(ICON_COLOR_KEY) || DEFAULT_ICON_COLOR_DARK;
            startButtonBgInput.value = localStorage.getItem(START_BUTTON_BG_KEY) || DEFAULT_START_BUTTON_BG_DARK;
            startMenuIconColorInput.value = localStorage.getItem(START_MENU_ICON_COLOR_KEY) || DEFAULT_START_MENU_ICON_COLOR_DARK;
            windowActiveBorderColorInput.value = localStorage.getItem(WINDOW_ACTIVE_BORDER_COLOR_KEY) || DEFAULT_WINDOW_ACTIVE_BORDER_DARK;
            enableContextMenuCheckbox.checked = localStorage.getItem(CONTEXT_MENU_ENABLED_KEY) !== 'false';
            windowGlowEnableCheckbox.checked = localStorage.getItem(WINDOW_GLOW_ENABLED_KEY) === 'true';
            const windowGlowSpeed = parseFloat(localStorage.getItem(WINDOW_GLOW_SPEED_KEY)) || 1.5; windowGlowSpeedSlider.value = windowGlowSpeed; windowGlowSpeedValueSpan.textContent = `${windowGlowSpeed.toFixed(1)}s`; windowGlowSpeedSlider.disabled = !windowGlowEnableCheckbox.checked;
            startButtonGlowEnableCheckbox.checked = localStorage.getItem(START_BUTTON_GLOW_ENABLED_KEY) === 'true';
            const currentCustomCSSFilename = localStorage.getItem(CUSTOM_CSS_FILENAME_KEY); customCSSFilenameSpan.textContent = currentCustomCSSFilename || 'None'; clearCustomCSSBtn.disabled = !currentCustomCSSFilename; applyCustomCSSBtn.disabled = true; cssStatusEl.textContent = '';
            taskbarColorInput.value = localStorage.getItem(TASKBAR_COLOR_KEY) || DEFAULT_TASKBAR_BG_DARK;
        }
        settingsAppEl._loadCurrentSettings = loadCurrentSettings;

        function highlightSelectedWallpaper() { const current = localStorage.getItem(WALLPAPER_KEY); wallpaperSelectorDiv.querySelectorAll('img').forEach(img => { img.classList.toggle('active', img.dataset.path === current); }); }
        function clearWallpaperSelectionUI() { wallpaperSelectorDiv.querySelectorAll('img').forEach(img => img.classList.remove('active')); }
        function clearGradientInputs() { bgColor1Input.value = DEFAULT_BG_COLOR1; bgColor2Input.value = DEFAULT_BG_COLOR2; }
        
        // --- Event Listeners ---
        // THEME SELECTOR EVENT LISTENER REMOVED FROM HERE
        applyGradientBtn.addEventListener('click', () => { const c1=bgColor1Input.value, c2=bgColor2Input.value; applyWallpaper(null); localStorage.removeItem(WALLPAPER_KEY); clearWallpaperSelectionUI(); applyGradientBackground(c1, c2); saveGradientColors(c1, c2); });
        wallpaperBtn.addEventListener('click', () => { wallpaperFileInput.onchange = (e) => { const file = e.target.files?.[0]; if (!file?.type.startsWith('image/')) return; const reader = new FileReader(); reader.onload = async (ev) => { const url = ev.target.result; if (url.length > 5*1024*1024) await showOSAlert("Warning: The selected wallpaper image is large and may impact performance.", "Large File"); applyWallpaper(url); try { localStorage.setItem(WALLPAPER_KEY, url); clearWallpaperSelectionUI(); clearGradientInputs(); localStorage.removeItem(BG_COLOR1_KEY); localStorage.removeItem(BG_COLOR2_KEY); } catch (err) { console.error("Save custom wallpaper error:", err); await showOSAlert("Failed to save the custom wallpaper. It might be too large for browser storage.", "Save Error"); applyWallpaper(null); localStorage.removeItem(WALLPAPER_KEY); }}; reader.onerror = () => showOSAlert("Failed to read the selected file.", "File Read Error"); reader.readAsDataURL(file); wallpaperFileInput.value = ''; wallpaperFileInput.onchange = null; }; wallpaperFileInput.click(); });
        clearWallpaperBtn.addEventListener('click', () => { const defaultWallpaperPath = DEFAULT_WALLPAPERS[0]; applyWallpaper(defaultWallpaperPath); localStorage.setItem(WALLPAPER_KEY, defaultWallpaperPath); localStorage.removeItem(BG_COLOR1_KEY); localStorage.removeItem(BG_COLOR2_KEY); loadCurrentSettings(); });
        disableAnimationsCheckbox.addEventListener('change', () => { const dis = disableAnimationsCheckbox.checked; applyAnimationSetting(dis); localStorage.setItem(ANIMATIONS_DISABLED_KEY, dis); });
        enableContextMenuCheckbox.addEventListener('change', () => { const enabled = enableContextMenuCheckbox.checked; localStorage.setItem(CONTEXT_MENU_ENABLED_KEY, enabled ? 'true' : 'false'); });
        iconColorInput.addEventListener('input', (e) => { const c=e.target.value; applyIconColor(c); localStorage.setItem(ICON_COLOR_KEY,c); });
        resetIconColorBtn.addEventListener('click', () => { localStorage.removeItem(ICON_COLOR_KEY); applyIconColor(DEFAULT_ICON_COLOR_DARK); iconColorInput.value=DEFAULT_ICON_COLOR_DARK; });
        startButtonBgInput.addEventListener('input', (e) => { const c=e.target.value; applyStartButtonColor(c); localStorage.setItem(START_BUTTON_BG_KEY,c); });
        resetStartButtonBgBtn.addEventListener('click', () => { localStorage.removeItem(START_BUTTON_BG_KEY); applyStartButtonColor(DEFAULT_START_BUTTON_BG_DARK); startButtonBgInput.value=DEFAULT_START_BUTTON_BG_DARK; });
        startMenuIconColorInput.addEventListener('input', (e) => { const c=e.target.value; applyStartMenuIconColor(c); localStorage.setItem(START_MENU_ICON_COLOR_KEY,c); });
        resetStartMenuIconColorBtn.addEventListener('click', () => { localStorage.removeItem(START_MENU_ICON_COLOR_KEY); applyStartMenuIconColor(DEFAULT_START_MENU_ICON_COLOR_DARK); startMenuIconColorInput.value=DEFAULT_START_MENU_ICON_COLOR_DARK; });
        windowActiveBorderColorInput.addEventListener('input', (e) => { const c=e.target.value; applyWindowActiveBorderColor(c); localStorage.setItem(WINDOW_ACTIVE_BORDER_COLOR_KEY,c); applyNonTransparentStyles(); });
        resetWindowActiveBorderColorBtn.addEventListener('click', () => { localStorage.removeItem(WINDOW_ACTIVE_BORDER_COLOR_KEY); applyWindowActiveBorderColor(DEFAULT_WINDOW_ACTIVE_BORDER_DARK); windowActiveBorderColorInput.value=DEFAULT_WINDOW_ACTIVE_BORDER_DARK; applyNonTransparentStyles(); });
        themePresetButtonsContainer.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON' && e.target.dataset.preset) { applyThemePreset(e.target.dataset.preset); setTimeout(loadCurrentSettings, 150); } });
        windowGlowEnableCheckbox.addEventListener('change', (e) => { const enabled = e.target.checked; applyWindowGlowSetting(enabled); localStorage.setItem(WINDOW_GLOW_ENABLED_KEY, enabled); windowGlowSpeedSlider.disabled = !enabled; });
        windowGlowSpeedSlider.addEventListener('input', (e) => { const speed = parseFloat(e.target.value); windowGlowSpeedValueSpan.textContent = `${speed.toFixed(1)}s`; applyWindowGlowSpeed(speed); localStorage.setItem(WINDOW_GLOW_SPEED_KEY, speed); });
        startButtonGlowEnableCheckbox.addEventListener('change', (e) => { const enabled = e.target.checked; applyStartButtonGlow(enabled); localStorage.setItem(START_BUTTON_GLOW_ENABLED_KEY, enabled); });
        triggerCustomCSSFileBtn.addEventListener('click', () => { customCSSFileInput.onchange = (e) => { const file = e.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (re) => { chosenFileContent = re.target.result; chosenFilename = file.name; customCSSFilenameSpan.textContent = `Pending: ${file.name}`; applyCustomCSSBtn.disabled = false; cssStatusEl.textContent = `File "${file.name}" ready. Click Apply.`; }; reader.onerror = () => { cssStatusEl.textContent = 'Error reading file.'; showOSAlert('Error reading file.'); }; reader.readAsText(file); } customCSSFileInput.value = null; customCSSFileInput.onchange = null; }; customCSSFileInput.click(); });
        applyCustomCSSBtn.addEventListener('click', () => { if (chosenFileContent && chosenFilename) { applyCustomCSS(chosenFileContent, chosenFilename); localStorage.setItem(CUSTOM_CSS_CONTENT_KEY, chosenFileContent); localStorage.setItem(CUSTOM_CSS_FILENAME_KEY, chosenFilename); customCSSFilenameSpan.textContent = chosenFilename; applyCustomCSSBtn.disabled = true; clearCustomCSSBtn.disabled = false; cssStatusEl.textContent = `Applied "${chosenFilename}".`; chosenFileContent = null; chosenFilename = null; } });
        clearCustomCSSBtn.addEventListener('click', () => { removeCustomCSS(); localStorage.removeItem(CUSTOM_CSS_CONTENT_KEY); localStorage.removeItem(CUSTOM_CSS_FILENAME_KEY); customCSSFilenameSpan.textContent = 'None'; clearCustomCSSBtn.disabled = true; applyCustomCSSBtn.disabled = true; cssStatusEl.textContent = 'Custom CSS cleared.'; });
        taskbarColorInput.addEventListener('input', (e) => { localStorage.setItem(TASKBAR_COLOR_KEY, e.target.value); applyNonTransparentStyles(); });
        resetTaskbarColorBtn.addEventListener('click', () => { localStorage.removeItem(TASKBAR_COLOR_KEY); taskbarColorInput.value = DEFAULT_TASKBAR_BG_DARK; applyNonTransparentStyles(); });
        clearCacheResetBtn.addEventListener('click', handleClearCacheAndReset);
        
        settingsAppEl.querySelectorAll('.settings-section').forEach(section => { const header = section.querySelector('h3.settings-section-toggle'); if (header) { header.addEventListener('click', () => { section.classList.toggle('collapsed'); }); } });

        // --- Init ---
        wallpaperSelectorDiv.innerHTML = ''; 
        DEFAULT_WALLPAPERS.forEach(path => { const img = document.createElement('img'); img.src = path; img.alt = `Wallpaper`; img.dataset.path = path; img.title = `Set as wallpaper`; img.addEventListener('click', () => { applyWallpaper(path); localStorage.setItem(WALLPAPER_KEY, path); highlightSelectedWallpaper(); localStorage.removeItem(BG_COLOR1_KEY); localStorage.removeItem(BG_COLOR2_KEY); }); wallpaperSelectorDiv.appendChild(img); });
        loadCurrentSettings();
    }
},

<!-- PART-003 -->

                <!-- -----------------------------------------------------------------------------
                <!-- --- SoundRecorder App ---
                <!-- -----------------------------------------------------------------------------
                 'SoundRecorder': { name: 'Sound Recorder', icon: '<i class="fa-solid fa-microphone"></i>', isCustom: false, init: (contentEl, windowId) => {
                     if (!navigator.mediaDevices?.getUserMedia || !window.MediaRecorder) { contentEl.innerHTML = `<div class="recorder-app"><h3 style="color:red;">Not Supported</h3><p>Sound recording is not supported by your browser.</p></div>`; return; }
                    contentEl.innerHTML = `<div class="recorder-app"><h3>Sound Recorder</h3><div class="status" id="sr-status-${windowId}">Ready</div><div class="controls"><button id="sr-record-${windowId}"><i class="fa-solid fa-circle"></i> Record</button><button id="sr-stop-${windowId}" disabled><i class="fa-solid fa-stop"></i> Stop</button></div><div class="recording-output" id="sr-output-${windowId}"></div></div>`;
                    const statusEl = contentEl.querySelector(`#sr-status-${windowId}`); const recordBtn = contentEl.querySelector(`#sr-record-${windowId}`); const stopBtn = contentEl.querySelector(`#sr-stop-${windowId}`); const outputEl = contentEl.querySelector(`#sr-output-${windowId}`); let mediaRecorder = null; let audioChunks = []; let currentStream = null;
                    async function startRecording() { recordBtn.disabled=true; statusEl.textContent='Requesting mic...'; outputEl.innerHTML=''; audioChunks=[]; try { const stream = await navigator.mediaDevices.getUserMedia({audio:true}); currentStream=stream; mediaRecorder=new MediaRecorder(stream); mediaRecorder.ondataavailable=e=>{if(e.data.size>0)audioChunks.push(e.data);}; mediaRecorder.onstop=()=>{ const blob=new Blob(audioChunks,{type:'audio/wav'}); const url=URL.createObjectURL(blob); outputEl.innerHTML=`<audio controls src="${url}"></audio><a href="${url}" download="recording.wav" class="download-link"><i class="fa-solid fa-download"></i> Download</a>`; statusEl.textContent='Stopped.'; recordBtn.disabled=false; stopBtn.disabled=true; recordBtn.classList.remove('recording'); stream.getTracks().forEach(t=>t.stop()); currentStream=null;}; mediaRecorder.onerror=e=>{ console.error("Recorder error:", e.error); statusEl.textContent=`Error: ${e.error.name}`; recordBtn.disabled=false; stopBtn.disabled=true; recordBtn.classList.remove('recording'); stream.getTracks().forEach(t=>t.stop()); currentStream=null; }; mediaRecorder.start(); statusEl.textContent='Recording...'; stopBtn.disabled=false; recordBtn.classList.add('recording'); } catch (err) { console.error("Mic access error:", err); statusEl.textContent=`Error: ${err.name}`; await showOSAlert(`Microphone access failed: ${err.name}`, "Permission Error"); recordBtn.disabled=false; } }
                    function stopRecording() { if (mediaRecorder?.state==='recording') mediaRecorder.stop(); }
                    recordBtn.addEventListener('click', startRecording); stopBtn.addEventListener('click', stopRecording);
                    if (openWindows[windowId]) { openWindows[windowId].cleanup = () => { stopRecording(); if(currentStream){currentStream.getTracks().forEach(t=>t.stop()); currentStream=null;} }; }
                 } },

                <!-- -----------------------------------------------------------------------------
                <!-- --- VideoRecorder App ---
                <!-- -----------------------------------------------------------------------------
                 'VideoRecorder': { name: 'Video Recorder', icon: '<i class="fa-solid fa-video"></i>', isCustom: false, init: (contentEl, windowId) => {
                     if (!navigator.mediaDevices?.getUserMedia || !window.MediaRecorder) { contentEl.innerHTML = `<div class="recorder-app"><h3 style="color:red;">Not Supported</h3><p>Video recording is not supported by your browser.</p></div>`; return; }
                     contentEl.innerHTML = `<div class="recorder-app"><h3>Video Recorder</h3><div class="preview"><video id="vr-preview-${windowId}" autoplay muted playsinline></video></div><div class="status" id="vr-status-${windowId}">Initializing...</div><div class="controls"><button id="vr-record-${windowId}" disabled><i class="fa-solid fa-circle"></i> Record</button><button id="vr-stop-${windowId}" disabled><i class="fa-solid fa-stop"></i> Stop</button></div><div class="recording-output" id="vr-output-${windowId}"></div></div>`;
                    const statusEl = contentEl.querySelector(`#vr-status-${windowId}`); const previewEl = contentEl.querySelector(`#vr-preview-${windowId}`); const recordBtn = contentEl.querySelector(`#vr-record-${windowId}`); const stopBtn = contentEl.querySelector(`#vr-stop-${windowId}`); const outputEl = contentEl.querySelector(`#vr-output-${windowId}`); let mediaRecorder = null; let recordedChunks = []; let previewStream = null;
                    async function setupPreview() { statusEl.textContent='Requesting cam/mic...'; recordBtn.disabled=true; stopBtn.disabled=true; outputEl.innerHTML=''; try { previewStream = await navigator.mediaDevices.getUserMedia({video:true, audio:true}); previewEl.srcObject=previewStream; statusEl.textContent='Preview active.'; recordBtn.disabled=false; } catch (err) { console.error("Media stream error:", err); statusEl.textContent=`Error: ${err.name}`; await showOSAlert(`Camera/microphone access failed: ${err.name}`, "Permission Error"); previewEl.srcObject=null; } }
                    function startRecording() { if(!previewStream||!previewStream.active){statusEl.textContent='Error: Preview inactive.'; showOSAlert("The camera preview stream is not active. Please re-open the app.", "Stream Error"); recordBtn.disabled=true; return;} recordBtn.disabled=true; stopBtn.disabled=false; outputEl.innerHTML=''; recordedChunks=[]; try { const options={mimeType:'video/webm;codecs=vp8,opus'}; if(!MediaRecorder.isTypeSupported(options.mimeType)){options.mimeType='video/webm'; if(!MediaRecorder.isTypeSupported(options.mimeType)){delete options.mimeType;}} mediaRecorder=new MediaRecorder(previewStream,options); mediaRecorder.ondataavailable=e=>{if(e.data.size>0)recordedChunks.push(e.data);}; mediaRecorder.onstop=()=>{ const mime=options.mimeType||'video/webm'; const blob=new Blob(recordedChunks,{type:mime}); const url=URL.createObjectURL(blob); const dlFn=`recording.${mime.split('/')[1].split(';')[0]}`; outputEl.innerHTML=`<video controls src="${url}"></video><a href="${url}" download="${dlFn}" class="download-link"><i class="fa-solid fa-download"></i> Download</a>`; statusEl.textContent='Stopped.'; recordBtn.disabled=false; stopBtn.disabled=true; recordBtn.classList.remove('recording');}; mediaRecorder.onerror=e=>{ console.error("Recorder error:", e.error); statusEl.textContent=`Error: ${e.error.name}`; recordBtn.disabled=false; stopBtn.disabled=true; recordBtn.classList.remove('recording');}; mediaRecorder.start(); statusEl.textContent='Recording...'; recordBtn.classList.add('recording');} catch (err) { console.error("Start recording error:", err); statusEl.textContent=`Rec Error: ${err.message}`; showOSAlert(`Failed to start recording: ${err.message}`, "Recording Error"); recordBtn.disabled=false; stopBtn.disabled=true; }}
                    function stopRecording() { if(mediaRecorder?.state==='recording')mediaRecorder.stop(); }
                    function stopPreview() { if(previewStream){previewStream.getTracks().forEach(t=>t.stop());} previewEl.srcObject=null; previewStream=null; statusEl.textContent='Preview stopped.'; recordBtn.disabled=true; stopBtn.disabled=true; }
                    recordBtn.addEventListener('click', startRecording); stopBtn.addEventListener('click', stopRecording); setupPreview();
                    if (openWindows[windowId]) { openWindows[windowId].cleanup = () => { stopRecording(); stopPreview(); }; }
                 } },
                <!-- -----------------------------------------------------------------------------
                <!-- --- Notes App ---
                <!-- -----------------------------------------------------------------------------
                    'NotesApp': {
    name: 'Notes',
    icon: '<i class="fa-solid fa-note-sticky"></i>',
    isCustom: false,
    init: (contentEl, windowId) => {
        contentEl.style.padding = '0';
        const appPrefix = `notes-app-${windowId}`;

        // --- HTML Structure (with new title input) ---
        contentEl.innerHTML = `
        <div class="notes-app-container">
            <style>
                /* Scoped styles for this app instance */
                .${appPrefix}-search-container { position: relative; padding: 5px 8px; border-bottom: 1px solid var(--notes-app-sidebar-border); }
                .${appPrefix}-search-container i { position: absolute; top: 50%; left: 16px; transform: translateY(-50%); color: #888; font-size: 0.9em; pointer-events: none; }
                .${appPrefix}-search-input { width: 100%; padding: 6px 8px 6px 30px; border-radius: 4px; border: 1px solid var(--border-secondary); background-color: var(--bg-primary); color: var(--text-primary); outline: none; }
                .${appPrefix}-search-input:focus { border-color: var(--accent-primary); }
                .notes-app-list li { display: flex; flex-direction: column; align-items: flex-start; gap: 2px; }
                .notes-app-list li .note-title { font-weight: 500; }
                .notes-app-list li .note-meta { font-size: 0.8em; color: #aaa; }
                .notes-app-list li.active .note-meta { color: #ddd; }
                .notes-app-sidebar-footer { padding: 8px; display: flex; justify-content: space-around; gap: 5px; border-top: 1px solid var(--notes-app-sidebar-border); margin-top: auto; }
                .notes-app-sidebar-footer button { flex-grow: 1; font-size: 0.85em; padding: 4px; background-color: var(--bg-tertiary); border: 1px solid var(--border-primary); color: var(--text-primary); border-radius: 3px; cursor: pointer; transition: background-color 0.1s ease, color 0.1s ease; }
                .notes-app-sidebar-footer button:hover { background-color: var(--border-primary); }
                .${appPrefix}-clear-btn:hover { background-color: var(--accent-danger) !important; color: white !important; }

                /* NEW styles for the title input */
                .${appPrefix}-title-input-container {
                    padding: 10px 15px 5px 15px;
                    border-bottom: 1px solid var(--border-primary);
                }
                .${appPrefix}-title-input {
                    width: 100%;
                    border: none;
                    background-color: transparent;
                    color: var(--text-secondary);
                    font-size: 1.5em;
                    font-weight: bold;
                    padding: 5px 0;
                    outline: none;
                }
                /* Adjust main editor padding */
                .notes-app-editor {
                    padding: 5px 15px 15px 15px;
                }
            </style>
            <div class="notes-app-sidebar">
                <div class="notes-app-sidebar-header">
                    <span id="${appPrefix}-note-count">Notes</span>
                    <button id="${appPrefix}-add" title="New Note"><i class="fa-solid fa-plus"></i></button>
                </div>
                <div class="${appPrefix}-search-container">
                    <i class="fa-solid fa-search"></i>
                    <input type="search" id="${appPrefix}-search" class="${appPrefix}-search-input" placeholder="Search notes...">
                </div>
                <ul class="notes-app-list" id="${appPrefix}-list"></ul>
                <div class="notes-app-sidebar-footer">
                    <button id="${appPrefix}-backup" title="Backup all notes to a file"><i class="fa-solid fa-download"></i> Backup</button>
                    <button id="${appPrefix}-restore" title="Restore notes from a file"><i class="fa-solid fa-upload"></i> Restore</button>
                    <button id="${appPrefix}-clear-all" class="${appPrefix}-clear-btn" title="Delete all notes"><i class="fa-solid fa-trash"></i> Clear All</button>
                </div>
            </div>
            <div class="notes-app-main">
                <div class="notes-app-toolbar" id="${appPrefix}-toolbar">
                    <button data-command="bold" title="Bold"><i class="fa-solid fa-bold"></i></button>
                    <button data-command="italic" title="Italic"><i class="fa-solid fa-italic"></i></button>
                    <button data-command="underline" title="Underline"><i class="fa-solid fa-underline"></i></button>
                    <button data-command="strikeThrough" title="Strikethrough"><i class="fa-solid fa-strikethrough"></i></button>
                    <div class="separator"></div>
                    <button data-command="insertUnorderedList" title="Bullet List"><i class="fa-solid fa-list-ul"></i></button>
                    <button data-command="insertOrderedList" title="Numbered List"><i class="fa-solid fa-list-ol"></i></button>
                    <div class="separator"></div>
                    <button data-command="createLink" title="Add Link"><i class="fa-solid fa-link"></i></button>
                    <button data-command="removeFormat" title="Clear Formatting"><i class="fa-solid fa-text-slash"></i></button>
                    <div class="separator" style="margin-left: auto;"></div>
                    <button id="${appPrefix}-export-txt" title="Export as Text File (.txt)" disabled><i class="fa-solid fa-file-alt"></i></button>
                    <button id="${appPrefix}-export-html" title="Export as HTML File (.html)" disabled><i class="fa-solid fa-file-code"></i></button>
                </div>
                <!-- NEW title input and updated editor structure -->
                <div id="${appPrefix}-title-input-container" class="${appPrefix}-title-input-container">
                    <input type="text" id="${appPrefix}-title-input" class="${appPrefix}-title-input" placeholder="Note Title..." disabled>
                </div>
                <div class="notes-app-editor" id="${appPrefix}-editor" contenteditable="false"></div>
                <input type="file" id="notes-restore-input" style="display:none;" accept=".json">
            </div>
        </div>`;

        // --- Element References ---
        const notesListEl = contentEl.querySelector(`#${appPrefix}-list`);
        const titleInputEl = contentEl.querySelector(`#${appPrefix}-title-input`);
        const editorEl = contentEl.querySelector(`#${appPrefix}-editor`);
        const addNoteBtn = contentEl.querySelector(`#${appPrefix}-add`);
        const toolbarEl = contentEl.querySelector(`#${appPrefix}-toolbar`);
        const searchInput = contentEl.querySelector(`#${appPrefix}-search`);
        const noteCountEl = contentEl.querySelector(`#${appPrefix}-note-count`);
        const backupBtn = contentEl.querySelector(`#${appPrefix}-backup`);
        const restoreBtn = contentEl.querySelector(`#${appPrefix}-restore`);
        const clearAllBtn = contentEl.querySelector(`#${appPrefix}-clear-all`);
        const notesRestoreInput = document.getElementById('notes-restore-input');
        const exportTxtBtn = contentEl.querySelector(`#${appPrefix}-export-txt`);
        const exportHtmlBtn = contentEl.querySelector(`#${appPrefix}-export-html`);

        // --- State Variables ---
        let notes = [];
        let currentNoteId = null;
        let saveTimeout = null;

        // --- Helper Functions ---
        const formatDate = (timestamp) => { try { const d = new Date(timestamp); const now = new Date(); if (d.toDateString() === now.toDateString()) return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); return d.toLocaleDateString(); } catch { return '...'; } };

        // --- Data Migration for old note format ---
        const migrateNoteFormat = (note) => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(note.content, 'text/html');
            const firstElement = doc.body.querySelector('h1, h2, h3, p, div');
            if (firstElement && firstElement.textContent.trim()) {
                note.title = firstElement.textContent.trim();
                firstElement.remove();
                note.body = doc.body.innerHTML;
            } else {
                note.title = 'Untitled Note';
                note.body = note.content;
            }
            delete note.content; // Remove the old property
            return note;
        };

        // --- Core Data & UI Functions ---
        const loadNotes = () => {
            try {
                notes = JSON.parse(localStorage.getItem(NOTES_STORAGE_KEY) || '[]');
                let wasMigrated = false;
                // Run migration for any old-format notes
                notes.forEach(note => {
                    if (note.content && typeof note.title === 'undefined') {
                        migrateNoteFormat(note);
                        wasMigrated = true;
                    }
                });
                if (wasMigrated) {
                    saveNotes(false); // Save the migrated format back to storage
                }
            } catch {
                notes = [];
            }
            renderNoteList();
            selectNote(notes[0]?.id);
        };
        const saveNotes = (render = true) => {
            if (currentNoteId) {
                const note = notes.find(n => n.id === currentNoteId);
                if (note && editorEl.isContentEditable) {
                    note.title = titleInputEl.value.trim() || 'Untitled Note';
                    note.body = editorEl.innerHTML;
                    note.lastModified = Date.now();
                }
            }
            try {
                localStorage.setItem(NOTES_STORAGE_KEY, JSON.stringify(notes));
                if (render) renderNoteList();
            } catch (e) {
                console.error("Save notes err:", e);
                showOSAlert("Failed to save notes. Storage may be full.", "Save Error");
            }
        };
        const scheduleSave = () => { clearTimeout(saveTimeout); saveTimeout = setTimeout(() => saveNotes(true), 1000); };
        const renderNoteList = () => {
            notesListEl.innerHTML = '';
            notes.sort((a, b) => (b.lastModified || 0) - (a.lastModified || 0));
            const query = searchInput.value.toLowerCase();
            const filtered = notes.filter(n => !query || (n.title.toLowerCase().includes(query) || (n.body || '').toLowerCase().includes(query)));
            filtered.forEach(n => { const li = document.createElement('li'); li.dataset.id = n.id; li.innerHTML = `<span class="note-title">${n.title || 'Untitled Note'}</span><span class="note-meta" title="Created: ${formatDate(n.createdAt || n.id)}">Modified: ${formatDate(n.lastModified)}</span>`; if (n.id === currentNoteId) li.classList.add('active'); li.onclick = () => selectNote(n.id); const delBtn = document.createElement('button'); delBtn.className = 'delete-note-btn'; delBtn.innerHTML = '<i class="fa-solid fa-trash-can"></i>'; delBtn.title = 'Delete'; delBtn.onclick = (e) => { e.stopPropagation(); deleteNote(n.id); }; li.appendChild(delBtn); notesListEl.appendChild(li); });
            noteCountEl.textContent = `Notes: ${notes.length}${query ? ` (found ${filtered.length})` : ''}`;
        };
        const selectNote = (id) => {
            if (saveTimeout) { clearTimeout(saveTimeout); saveNotes(true); }
            if (!id && notes.length > 0) id = notes[0].id;
            if (!id) {
                editorEl.innerHTML = ''; editorEl.contentEditable = false;
                titleInputEl.value = ''; titleInputEl.disabled = true;
                currentNoteId = null; exportTxtBtn.disabled = true; exportHtmlBtn.disabled = true;
                renderNoteList();
                return;
            }
            const note = notes.find(n => n.id === id);
            if (note) {
                currentNoteId = id;
                titleInputEl.value = note.title || 'Untitled Note';
                editorEl.innerHTML = note.body || '';
                editorEl.contentEditable = true;
                titleInputEl.disabled = false;
                exportTxtBtn.disabled = false; exportHtmlBtn.disabled = false;
                editorEl.focus();
                renderNoteList();
            }
        };

        // --- Actions ---
        const addNewNote = () => {
            const now = Date.now();
            const newNote = { id: now, createdAt: now, title: 'New Note', body: '<p>Start writing here...</p>', lastModified: now };
            notes.unshift(newNote);
            selectNote(newNote.id);
            saveNotes();
            titleInputEl.focus(); // Focus the new title input
        };
        const deleteNote = async (id) => { if (await showOSConfirmDanger('Permanently delete this note?')) { notes = notes.filter(n => n.id !== id); if (currentNoteId === id) { currentNoteId = null; selectNote(); } saveNotes(); } };
        const handleLinkCreation = async () => { editorEl.focus(); const selection = window.getSelection(); if (!selection || selection.rangeCount === 0) return; const range = selection.getRangeAt(0); const selectedText = selection.toString(); const url = await showOSPrompt('Enter the full URL:', 'Create Link', selectedText.startsWith('http') ? selectedText : 'https://'); if (!url) return; selection.removeAllRanges(); selection.addRange(range); document.execCommand('createLink', false, url); const parentElement = selection.anchorNode.parentElement; if (parentElement && parentElement.tagName === 'A') { parentElement.target = '_blank'; parentElement.rel = 'noopener noreferrer'; } scheduleSave(); };

        // --- Export, Backup, Restore, and Clear ---
        const handleExport = async (format) => {
            if (!currentNoteId) return;
            const note = notes.find(n => n.id === currentNoteId);
            if (!note) return;
            const title = note.title.replace(/[<>:"/\\|?*]/g, '_') || 'note';
            const defaultFilename = `${title}.${format}`;
            const filename = await showOSPrompt(`Save file as:`, 'Export Note', defaultFilename);
            if (!filename) return;

            let content, mimeType;
            if (format === 'html') {
                content = `<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="UTF-8">\n<title>${note.title}</title>\n<style>body{font-family:sans-serif;line-height:1.6;max-width:800px;margin:2rem auto;padding:1rem;background-color:#fdfdfd;color:#111;} h1{margin-top:0;} ul,ol{padding-left:2em;}a{color:#0078d4;}</style>\n</head>\n<body>\n<h1>${note.title}</h1>\n${note.body}\n</body>\n</html>`;
                mimeType = 'text/html;charset=utf-8';
            } else {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = note.body.replace(/<p>|<\/div>|<\/li>|<\/h[1-6]>/gi, '\n').replace(/<br\s*\/?>/gi, '\n');
                const bodyText = tempDiv.textContent.replace(/^\s*\n/gm, '').trim();
                content = `${note.title}\n====================\n\n${bodyText}`;
                mimeType = 'text/plain;charset=utf-8';
            }
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = filename; a.style.display = 'none'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        };
        const handleBackup = () => { if (notes.length === 0) { showOSAlert("There are no notes to backup.", "Backup"); return; } const dataStr = JSON.stringify(notes, null, 2); const blob = new Blob([dataStr], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `simplex-os-notes-backup-${new Date().toISOString().slice(0, 10)}.json`; a.click(); URL.revokeObjectURL(url); };
        const handleRestore = async () => { if (!(await showOSConfirmDanger("Restoring from a backup will OVERWRITE all current notes. Continue?", "Restore Warning"))) return; const restoreFileHandler = (event) => { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = async (e) => { try { const restoredNotes = JSON.parse(e.target.result); if (!Array.isArray(restoredNotes) || (restoredNotes.length > 0 && (!restoredNotes[0].id || !restoredNotes[0].hasOwnProperty('title')))) { throw new Error("Invalid notes backup file format. Must contain 'title' property."); } notes = restoredNotes; saveNotes(false); loadNotes(); await showOSAlert("Notes have been restored successfully.", "Restore Complete"); } catch (err) { await showOSAlert(`Restore failed: ${err.message}`, "Restore Error"); } }; reader.onerror = () => showOSAlert("Failed to read the backup file.", "File Error"); reader.readAsText(file); notesRestoreInput.removeEventListener('change', restoreFileHandler); notesRestoreInput.value = null; }; notesRestoreInput.addEventListener('change', restoreFileHandler, { once: true }); notesRestoreInput.click(); };
        const handleClearAll = async () => { if (notes.length === 0) { showOSAlert("There are no notes to clear.", "Clear All"); return; } if (await showOSConfirmDanger("This will permanently delete ALL notes. This action cannot be undone. Are you sure?", "Clear All Notes")) { notes = []; currentNoteId = null; saveNotes(false); selectNote(null); await showOSAlert("All notes have been cleared.", "Success"); } };

        // --- Event Listeners ---
        toolbarEl.addEventListener('click', (e) => { const button = e.target.closest('button[data-command]'); if (!button || !editorEl.isContentEditable) return; const cmd = button.dataset.command; if (cmd === 'createLink') { handleLinkCreation(); } else { document.execCommand(cmd, false, button.dataset.value || null); scheduleSave(); } });
        editorEl.addEventListener('click', async (e) => { if (e.target.tagName === 'A' && e.target.href) { e.preventDefault(); if (await showOSConfirm(`Open this link in a new tab?\n\n${e.target.href}`, 'Open External Link')) window.open(e.target.href, '_blank', 'noopener,noreferrer'); } });
        editorEl.addEventListener('input', scheduleSave);
        titleInputEl.addEventListener('input', scheduleSave);
        editorEl.addEventListener('blur', () => { if (saveTimeout) { clearTimeout(saveTimeout); saveNotes(true); } });
        titleInputEl.addEventListener('blur', () => { if (saveTimeout) { clearTimeout(saveTimeout); saveNotes(true); } });
        searchInput.addEventListener('input', renderNoteList);
        addNoteBtn.addEventListener('click', addNewNote);
        backupBtn.addEventListener('click', handleBackup);
        restoreBtn.addEventListener('click', handleRestore);
        clearAllBtn.addEventListener('click', handleClearAll);
        exportTxtBtn.addEventListener('click', () => handleExport('txt'));
        exportHtmlBtn.addEventListener('click', () => handleExport('html'));

        // --- Initialization & Cleanup ---
        loadNotes();
        if (openWindows[windowId]) { openWindows[windowId].cleanup = () => { clearTimeout(saveTimeout); if (currentNoteId) saveNotes(false); }; }
    }
},
                <!-- -----------------------------------------------------------------------------
                <!-- --- AppInstaller App ---
                <!-- -----------------------------------------------------------------------------
                 'AppInstaller': {
    name: 'App Installer',
    icon: '<i class="fa-solid fa-download"></i>',
    isCustom: false,
    init: (contentEl, windowId) => {
        contentEl.style.padding = '0';
        contentEl.innerHTML = `
            <div class="app-installer-app">
                <div class="app-installer-header">
                    <h3>App Management</h3>
                    <p>Discover new apps or manage your installed ones.</p>
                    <button id="installer-open-library-${windowId}" title="Find more apps (opens new tab)"><i class="fa-solid fa-store"></i> App Library</button>
                    <button id="installer-choose-file-${windowId}"><i class="fa-solid fa-upload"></i> Install from .js File...</button>
                    <div class="status" id="installer-status-${windowId}">Ready</div>
                </div>
                <div class="app-installer-list-container">
                    <h4>Installed Custom Apps:</h4>
                    <ul class="app-installer-list" id="installer-custom-app-list-${windowId}">
                        <li class="no-apps">None installed yet.</li>
                    </ul>
                </div>
            </div>`;

        const chooseFileBtn = contentEl.querySelector(`#installer-choose-file-${windowId}`);
        const openLibraryBtn = contentEl.querySelector(`#installer-open-library-${windowId}`);
        const statusEl = contentEl.querySelector(`#installer-status-${windowId}`);
        const customAppListUl = contentEl.querySelector(`#installer-custom-app-list-${windowId}`);
        const appInstallerAppEl = contentEl.querySelector('.app-installer-app');

        const populateInstalledList = () => {
            customAppListUl.innerHTML = '';
            let customAppsFound = false;
            Object.keys(apps).sort((a, b) => apps[a].name.localeCompare(apps[b].name)).forEach(appId => {
                if (apps[appId].isCustom) {
                    const appConfig = apps[appId];
                    const li = document.createElement('li');
                    li.innerHTML = `
                        <span class="icon">${getIconHtml(appConfig, 'small')}</span>
                        <span class="app-name">${appConfig.name}</span>
                        <button class="uninstall-app-button" data-app-id="${appId}" title="Uninstall ${appConfig.name}"><i class="fa-solid fa-trash-can"></i></button>
                    `;
                    const uninstallBtn = li.querySelector('.uninstall-app-button');
                    uninstallBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        uninstallApp(appId);
                    });
                    customAppListUl.appendChild(li);
                    customAppsFound = true;
                }
            });
            if (!customAppsFound) {
                const li = document.createElement('li');
                li.classList.add('no-apps');
                li.textContent = 'None installed yet.';
                customAppListUl.appendChild(li);
            }
        };
        appInstallerAppEl._populateList = populateInstalledList;

        const handleInstallFile = async (file) => {
            statusEl.textContent = `Reading ${file.name}...`;
            if (!file?.name.endsWith('.js')) {
                statusEl.textContent = "Error: Select a '.js' file.";
                await showOSAlert("Please select a valid '.js' file.", "Invalid File Type");
                return;
            }
            const confirmed = await showOSConfirmDanger(`⚠️ SECURITY RISK ⚠️\n\nAre you sure you want to install "${file.name}"?\nThis will execute code directly from the file, which could be malicious.\n\nONLY INSTALL FILES FROM TRUSTED SOURCES.`, "Security Warning");
            if (!confirmed) {
                statusEl.textContent = "Installation cancelled.";
                return;
            }
            const reader = new FileReader();
            reader.onload = async (e) => {
                const content = e.target.result;
                let cfg = null;
                try {
                    statusEl.textContent = `Executing ${file.name}...`;
                    eval(content);
                    if (typeof simplexOS_AppConfig === 'object' && simplexOS_AppConfig !== null && typeof simplexOS_AppConfig.init === 'function') {
                        cfg = simplexOS_AppConfig;
                    } else {
                        throw new Error("Invalid or missing 'simplexOS_AppConfig' object.");
                    }
                    const id = `custom-${cfg.name.replace(/\s+/g, '_')}-${Date.now()}`;
                    apps[id] = {
                        name: cfg.name,
                        icon: cfg.icon || '<i class="fa-solid fa-puzzle-piece"></i>',
                        iconPath: cfg.iconPath || null,
                        isCustom: true,
                        init: cfg.init,
                        defaultSize: cfg.defaultSize || null // <-- Add defaultSize property
                    };
                    saveInstalledApps();
                    populateAppList();
                    populateInstalledList();
                    statusEl.textContent = `App "${cfg.name}" installed successfully!`;
                    await showOSAlert(`App "${cfg.name}" has been installed successfully! You can now find it in the Start Menu.`, "Installation Complete");
                } catch (err) {
                    statusEl.textContent = `Install Error: ${err.message}`;
                    await showOSAlert(`An error occurred during installation:\n\n${err.message}`, "Installation Error");
                    console.error("Installation script error:", err);
                } finally {
                    if (typeof simplexOS_AppConfig !== 'undefined') {
                        simplexOS_AppConfig = undefined;
                    }
                }
            };
            reader.onerror = () => {
                statusEl.textContent = "Error reading file.";
                showOSAlert("An error occurred while trying to read the selected file.", "File Read Error");
            };
            reader.readAsText(file);
        };
        chooseFileBtn.addEventListener('click', () => {
            statusEl.textContent = "Waiting for file selection...";
            const fileInputHandler = (event) => {
                if (event.target.files?.length) {
                    handleInstallFile(event.target.files[0]);
                } else {
                    statusEl.textContent = "No file selected.";
                }
                event.target.value = null; 
                appFileInput.removeEventListener('change', fileInputHandler);
            };
            appFileInput.addEventListener('change', fileInputHandler);
            appFileInput.click();
        });

        openLibraryBtn.addEventListener('click', async () => {
            if (localStorage.getItem(APP_LIBRARY_GUIDE_SHOWN_KEY) !== 'true') {
                await showOSAlert('You are being taken to the App Library in a new tab.\n\nTo install an app from the library, find an app you like and click its "Install" button. Your Simplex OS will then ask for confirmation to complete the installation.', 'App Library Guide');
                localStorage.setItem(APP_LIBRARY_GUIDE_SHOWN_KEY, 'true');
            }
            window.open('applibrary/', '_blank', 'noopener,noreferrer');
            statusEl.textContent = "Opened App Library tab.";
        });

        populateInstalledList();

        if (openWindows[windowId]) {
            openWindows[windowId].cleanup = () => {
                appFileInput.value = null;
                delete appInstallerAppEl._populateList;
            };
        }
    }
},
            }; // End of apps object
            
            // --- Widget Functions ---
            function createWidget(widgetType, instanceId = null, position = null) {
                const widgetConfig = widgets[widgetType];
                if (!widgetConfig) return;

                const id = instanceId || `widget-instance-${Date.now()}`;
                const widgetEl = document.createElement('div');
                widgetEl.className = 'desktop-widget';
                widgetEl.id = id;
                widgetEl.style.width = `${widgetConfig.defaultSize.width}px`;
                widgetEl.style.height = `${widgetConfig.defaultSize.height}px`;
                widgetEl.style.zIndex = nextWidgetZIndex++;
                widgetEl.innerHTML = `
                    <div class="widget-dragger"></div>
                    <div class="widget-content"></div>
                    <button class="widget-close-button" title="Remove Widget"><i class="fa-solid fa-xmark"></i></button>`;
                
                const closeButton = widgetEl.querySelector('.widget-close-button');
                closeButton.onclick = (e) => { e.stopPropagation(); removeWidget(id); };

                const dragger = widgetEl.querySelector('.widget-dragger');
                let isDragging = false, dragStartX, dragStartY, initialLeft, initialTop;

                const dragStart = (e) => {
                    e.preventDefault();
                    isDragging = true;
                    widgetEl.classList.add('dragging');
                    widgetEl.style.zIndex = nextWidgetZIndex++;
                    const point = e.type.startsWith('touch') ? e.touches[0] : e;
                    dragStartX = point.clientX;
                    dragStartY = point.clientY;
                    initialLeft = widgetEl.offsetLeft;
                    initialTop = widgetEl.offsetTop;
                    document.addEventListener('mousemove', dragMove);
                    document.addEventListener('mouseup', dragEnd);
                    document.addEventListener('touchmove', dragMove, { passive: false });
                    document.addEventListener('touchend', dragEnd);
                };

                const dragMove = (e) => {
                    if (!isDragging) return;
                    const point = e.type.startsWith('touch') ? e.touches[0] : e;
                    const dx = point.clientX - dragStartX;
                    const dy = point.clientY - dragStartY;
                    widgetEl.style.left = `${initialLeft + dx}px`;
                    widgetEl.style.top = `${initialTop + dy}px`;
                };

                const dragEnd = () => {
                    if (!isDragging) return;
                    isDragging = false;
                    widgetEl.classList.remove('dragging');
                    desktopWidgets[id].position = { left: widgetEl.style.left, top: widgetEl.style.top };
                    saveDesktopWidgets();
                    document.removeEventListener('mousemove', dragMove);
                    document.removeEventListener('mouseup', dragEnd);
                    document.removeEventListener('touchmove', dragMove);
                    document.removeEventListener('touchend', dragEnd);
                };

                dragger.addEventListener('mousedown', dragStart);
                dragger.addEventListener('touchstart', dragStart, { passive: false });

                desktop.appendChild(widgetEl);

                const contentEl = widgetEl.querySelector('.widget-content');
                
                desktopWidgets[id] = {
                    element: widgetEl,
                    type: widgetType,
                    cleanup: null,
                    position: {
                        left: position ? position.left : `${(Object.keys(desktopWidgets).length * 20) + 20}px`,
                        top: position ? position.top : `${(Object.keys(desktopWidgets).length * 20) + 20}px`
                    }
                };

                widgetEl.style.left = desktopWidgets[id].position.left;
                widgetEl.style.top = desktopWidgets[id].position.top;
                
                try {
                    widgetConfig.init(contentEl, id);
                } catch (e) {
                    console.error(`Error initializing widget ${widgetType}:`, e);
                    contentEl.innerHTML = `<p style="color:red">Widget Error</p>`;
                }

                if (!instanceId) { // Only save if it's a newly created widget
                    saveDesktopWidgets();
                }
            }

            async function removeWidget(instanceId) {
                const widget = desktopWidgets[instanceId];
                if (!widget) return;
                
                const confirmed = await showOSConfirmDanger(`Are you sure you want to remove this "${widgets[widget.type].name}" widget?`, "Confirm Removal");
                if (!confirmed) return;

                if (widget.cleanup) widget.cleanup();
                widget.element.remove();

                // Also remove any data stored in localStorage for this widget instance
                const storageKey = `${WIDGET_DATA_PREFIX}${instanceId}`;
                localStorage.removeItem(storageKey);
                
                delete desktopWidgets[instanceId];
                saveDesktopWidgets();
            }

            function saveDesktopWidgets() {
                const toSave = Object.keys(desktopWidgets).map(id => ({
                    id: id,
                    type: desktopWidgets[id].type,
                    position: desktopWidgets[id].position
                }));
                try {
                    localStorage.setItem(DESKTOP_WIDGETS_KEY, JSON.stringify(toSave));
                } catch (e) {
                    console.error("Error saving widgets:", e);
                }
            }

            function loadDesktopWidgets() {
                const stored = localStorage.getItem(DESKTOP_WIDGETS_KEY);
                if (stored) {
                    try {
                        const loadedWidgets = JSON.parse(stored);
                        if (Array.isArray(loadedWidgets)) {
                            loadedWidgets.forEach(widgetData => {
                                createWidget(widgetData.type, widgetData.id, widgetData.position);
                            });
                        }
                    } catch (e) {
                        console.error("Error loading widgets:", e);
                        localStorage.removeItem(DESKTOP_WIDGETS_KEY);
                    }
                }
            }

            // --- Taskbar Overflow Adjustment ---
            function adjustTaskbarHeight() {
                const scrollbarVisible = taskbarApps.scrollWidth > taskbarApps.clientWidth;
                taskbar.classList.toggle('has-scrollbar', scrollbarVisible);
            }

            // --- Lock Screen and Welcome Screen System ---
            function createLockScreenElements() {
                if (!lockScreenOverlay) { lockScreenOverlay = document.createElement('div'); lockScreenOverlay.id = 'lock-screen-overlay'; document.body.appendChild(lockScreenOverlay); }
                lockScreenOverlay.className = 'hidden';
                passwordSetupScreen = document.createElement('div'); passwordSetupScreen.id = 'password-setup-screen'; passwordSetupScreen.className = 'lock-screen-dialog hidden';
                passwordSetupScreen.innerHTML = `<h2>Set Up Simplex OS Access</h2><p>Create a password to secure your session or skip this step.</p><p class="security-note"><strong>Note:</strong> Password is saved locally and is for demonstration. Not for real security.</p><input type="password" id="new-password" placeholder="New Password" autocomplete="new-password"><input type="password" id="confirm-password" placeholder="Confirm Password" autocomplete="new-password"><div class="lock-screen-message" id="setup-message"></div><button id="set-password-btn">Set Password</button><button id="skip-password-btn">Skip</button>`;
                loginScreen = document.createElement('div'); loginScreen.id = 'login-screen'; loginScreen.className = 'lock-screen-dialog hidden';
                loginScreen.innerHTML = `<h2>Simplex OS Locked</h2><input type="password" id="login-password" placeholder="Password" autocomplete="current-password"><div class="lock-screen-message" id="login-message"></div><button id="login-btn">Unlock</button><p class="reset-note">Forgot password? <a href="#" id="reset-password-info">Reset instructions</a>.</p>`;
                lockScreenOverlay.appendChild(passwordSetupScreen); lockScreenOverlay.appendChild(loginScreen);
                document.getElementById('set-password-btn').addEventListener('click', handleSetPassword);
                document.getElementById('skip-password-btn').addEventListener('click', handleSkipPassword);
                document.getElementById('login-btn').addEventListener('click', handleLogin);
                document.getElementById('login-password').addEventListener('keypress', (e) => { if (e.key === 'Enter') handleLogin(); });
                document.getElementById('reset-password-info').addEventListener('click', (e) => { e.preventDefault(); showOSAlert("Password Reset Instructions:\n\nTo reset your password, you must clear your browser's cache and site data for this page.\n\n⚠️ WARNING: This action will permanently delete ALL your Simplex OS data, including installed apps, notes, and custom settings. This is irreversible.\n\nTo do this (general steps for most browsers):\n1. Go to Browser Settings.\n2. Find 'Privacy and Security' or 'Site Settings'.\n3. Look for 'Cookies and site data' or 'Clear browsing data'.\n4. Find this specific site and clear its data, or use the advanced 'Clear browsing data' option to clear 'Cookies and other site data' and 'Cached images and files' for all sites (or for a specific time range that includes your Simplex OS usage).", "Password Reset"); });
            }

            function createWelcomeScreenElement() {
                if (!welcomeScreenOverlay) { welcomeScreenOverlay = document.createElement('div'); welcomeScreenOverlay.id = 'welcome-screen-overlay'; document.body.appendChild(welcomeScreenOverlay); }
                welcomeScreenOverlay.className = 'hidden';
                welcomeScreenOverlay.innerHTML = `<div class="welcome-dialog"><h2>Welcome to Simplex OS!</h2><p>This is a web-based desktop environment with a set of basic applications. Here are a few tips to get started:</p><ul><li><strong>Start Menu:</strong> Click the 'Start' button to find and launch apps.</li><li><strong>Desktop Shortcuts:</strong> In the Start Menu, use the action buttons on an app to add or remove desktop shortcuts.</li><li><strong>Settings:</strong> Customize your theme, background, and other options in the 'Settings' app.</li><li><strong>Windows:</strong> Drag title bars to move, double-click to maximize/restore, and resize from corners.</li><li><strong>Right-Click/Long-Press:</strong> Try this on the desktop, text fields, or window title bars for context menus.</li></ul><p><strong>Want more apps?</strong> Use the 'App Installer' to either load your own custom <code>.js</code> app files or visit the <strong>App Library</strong> to discover and install new apps with one click.</p><button id="close-welcome-btn">Got it, let's start!</button></div>`;
                document.getElementById('close-welcome-btn').addEventListener('click', () => { welcomeScreenOverlay.classList.add('hidden'); localStorage.setItem(WELCOME_SCREEN_SHOWN_KEY, 'true'); });
            }

            function simpleHash(str) { const key = "SimplexOSKey_S0m3wh4tM0r3S3cur3"; let hashed = ""; for (let i = 0; i < str.length; i++) { hashed += String.fromCharCode(str.charCodeAt(i) ^ key.charCodeAt(i % key.length) ^ (i % 256)); } const prefix = "S!mpL3x"; const suffix = "P@$$"; return btoa(prefix + hashed + suffix); }
            function checkPassword(inputPassword, storedHash) { return simpleHash(inputPassword) === storedHash; }
            function setMessage(elementId, text, isSuccess = false) { const el = document.getElementById(elementId); if (el) { el.textContent = text; el.style.color = isSuccess ? 'var(--accent-success)' : 'var(--accent-danger)'; el.style.backgroundColor = isSuccess ? 'rgba(0,255,0,0.1)' : 'rgba(255,0,0,0.1)'; } }
            function handleSetPassword() { const newPass = document.getElementById('new-password').value; const confirmPass = document.getElementById('confirm-password').value; if (!newPass || !confirmPass) { setMessage('setup-message', "Please fill both password fields."); return; } if (newPass !== confirmPass) { setMessage('setup-message', "Passwords do not match."); return; } if (newPass.length < 4) { setMessage('setup-message', "Password must be at least 4 characters."); return; } localStorage.setItem(PASSWORD_HASH_KEY, simpleHash(newPass)); localStorage.removeItem(PASSWORD_SETUP_SKIPPED_KEY); setMessage('setup-message', "Password set successfully!", true); setTimeout(unlockOS, 1000); }
            function handleSkipPassword() { localStorage.setItem(PASSWORD_SETUP_SKIPPED_KEY, 'true'); localStorage.removeItem(PASSWORD_HASH_KEY); unlockOS(); }
            function handleLogin() { const pass = document.getElementById('login-password').value; const storedHash = localStorage.getItem(PASSWORD_HASH_KEY); if (checkPassword(pass, storedHash)) { setMessage('login-message', "Success!", true); setTimeout(unlockOS, 500); } else { setMessage('login-message', "Incorrect password."); document.getElementById('login-password').value = ''; document.getElementById('login-password').focus(); } }

            function unlockOS() {
                osLocked = false;
                if (lockScreenOverlay) lockScreenOverlay.classList.add('hidden');
                if (passwordSetupScreen) passwordSetupScreen.classList.add('hidden');
                if (loginScreen) loginScreen.classList.add('hidden');
                initializeMainOS();
                if (!localStorage.getItem(WELCOME_SCREEN_SHOWN_KEY)) {
                    if (welcomeScreenOverlay) welcomeScreenOverlay.classList.remove('hidden');
                }
            }

            function checkLockState() {
                createLockScreenElements(); createWelcomeScreenElement();
                const storedHash = localStorage.getItem(PASSWORD_HASH_KEY);
                const skippedSetup = localStorage.getItem(PASSWORD_SETUP_SKIPPED_KEY) === 'true';
                lockScreenOverlay.classList.remove('hidden');
                if (storedHash) { loginScreen.classList.remove('hidden'); passwordSetupScreen.classList.add('hidden'); setTimeout(() => document.getElementById('login-password')?.focus(), 0); }
                else if (skippedSetup) { unlockOS(); }
                else { passwordSetupScreen.classList.remove('hidden'); loginScreen.classList.add('hidden'); setTimeout(() => document.getElementById('new-password')?.focus(), 0); }
            }

            // --- Custom Context Menu ---
            function createContextMenuElement() {
                if (!customContextMenu) { customContextMenu = document.createElement('div'); customContextMenu.id = 'custom-context-menu'; document.body.appendChild(customContextMenu); }
                customContextMenu.className = 'hidden';
                document.addEventListener('click', (e) => { if (customContextMenu && !customContextMenu.classList.contains('hidden') && !e.target.closest('#custom-context-menu')) { customContextMenu.classList.add('hidden'); } });
                document.addEventListener('touchstart', (e) => { if (customContextMenu && !customContextMenu.classList.contains('hidden') && !e.target.closest('#custom-context-menu')) { customContextMenu.classList.add('hidden'); } }, { passive: true });
            }

            async function closeAllWindows() { if (Object.keys(openWindows).length > 0 && await showOSConfirmDanger("Are you sure you want to close all open windows?", "Close All")) { Object.keys(openWindows).forEach(windowId => closeWindow(windowId)); } }

            function handleContextMenu(e, isTouchEvent = false) {
                const contextMenuEnabled = localStorage.getItem(CONTEXT_MENU_ENABLED_KEY) !== 'false';
                if (!contextMenuEnabled || osLocked || e.target.closest('#lock-screen-overlay') || e.target.closest('#welcome-screen-overlay') || e.target.closest('#os-dialog-overlay')) { return; }

                const target = e.target;
                let mainItems = [];
                let smallItems = [];
                let showCustomMenu = false;

                // Block custom menu over window content and most parts of widgets
                const onWidgetContent = target.closest('.widget-content');
                if (target.closest('.window .window-content') || (onWidgetContent && !onWidgetContent.closest('.image-frame-widget'))) {
                    customContextMenu.classList.add('hidden');
                    return;
                }

                const onDesktop = target.closest('#desktop'); const onDesktopIcon = target.closest('.desktop-icon');
                const onTaskbar = target.closest('#taskbar'); const onStartButton = target.closest('#start-button');
                const onStartMenu = target.closest('#start-menu'); const onWindowTitleBar = target.closest('.window .title-bar');
                const onWindowControls = target.closest('.window .title-bar .window-controls button');

                if (onWindowTitleBar && !onWindowControls) {
                    const windowEl = target.closest('.window'); const windowId = windowEl?.id;
                    if (windowId && openWindows[windowId]) {
                        showCustomMenu = true; const appWindow = openWindows[windowId];
                        if (!appWindow.isMaximized && !appWindow.isMinimized) {
                             mainItems.push({ label: 'Minimize', icon: 'fa-window-minimize', action: () => minimizeWindow(windowId) });
                             mainItems.push({ label: 'Maximize', icon: 'fa-window-maximize', action: () => maximizeWindow(windowId) });
                        } else if (appWindow.isMaximized) {
                             mainItems.push({ label: 'Minimize', icon: 'fa-window-minimize', action: () => minimizeWindow(windowId) });
                             mainItems.push({ label: 'Restore', icon: 'fa-window-restore', action: () => restoreWindow(windowId) });
                        }
                        mainItems.push({ type: 'separator' });
                        mainItems.push({ label: 'Close', icon: 'fa-xmark', action: () => closeWindow(windowId) });
                    }
                } else if (onStartButton) {
                    showCustomMenu = true;
                    mainItems.push({ label: 'Settings', icon: 'fa-gear', action: () => createWindow('Settings') });
                    mainItems.push({ label: 'App Installer', icon: 'fa-download', action: () => createWindow('AppInstaller') });
                    mainItems.push({ type: 'separator' });
                    mainItems.push({ label: 'Close All Windows', icon: 'fa-rectangle-xmark', action: async () => await closeAllWindows() });
                    mainItems.push({ label: 'Reset Simplex OS...', icon: 'fa-triangle-exclamation', action: async () => await handleClearCacheAndReset() });
                } else if (onDesktop && !target.closest('.desktop-widget')) { // Don't show desktop menu over a widget
                    showCustomMenu = true;
                    if (onDesktopIcon && onDesktopIcon.dataset.app) {
                        const appId = onDesktopIcon.dataset.app;
                        mainItems.push({ label: `Open ${apps[appId]?.name || 'App'}`, icon: 'fa-folder-open', action: () => createWindow(appId) });
                        mainItems.push({ label: 'Remove shortcut', icon: 'fa-trash-can', action: () => removeDesktopShortcut(appId) });
                        mainItems.push({ type: 'separator' });
                    }
                    mainItems.push({ label: 'Add Widget', icon: 'fa-puzzle-piece', action: () => showAddWidgetDialog() });
                    mainItems.push({ type: 'separator' });
                    mainItems.push({ label: desktopIconsVisible ? 'Hide Icons' : 'Show Icons', icon: `fa-eye${desktopIconsVisible ? '-slash' : ''}`, action: () => { desktopIconsVisible = !desktopIconsVisible; applyDesktopIconsVisibility(desktopIconsVisible); localStorage.setItem(DESKTOP_ICONS_VISIBLE_KEY, desktopIconsVisible); } });
                    smallItems.push({ label: 'Arrange', icon: 'fa-table-cells', action: () => { desktopIconArrangement = desktopIconArrangement === 'row' ? 'column' : 'row'; applyDesktopIconArrangement(desktopIconArrangement); localStorage.setItem(DESKTOP_ICON_ARRANGEMENT_KEY, desktopIconArrangement); } });
                    smallItems.push({ label: 'Personalize', icon: 'fa-palette', action: () => createWindow('Settings') });
                    smallItems.push({ label: 'Close All', icon: 'fa-rectangle-xmark', action: async () => await closeAllWindows() });
                } else if (onTaskbar) {
                    showCustomMenu = true; const taskbarAppButton = target.closest('.taskbar-app-button');
                    if (taskbarAppButton && taskbarAppButton.id) {
                        const windowId = taskbarAppButton.id.replace('taskbar-', ''); const appWindow = openWindows[windowId];
                        if (appWindow) {
                            if (!appWindow.isMinimized) mainItems.push({ label: 'Minimize', icon: 'fa-window-minimize', action: () => minimizeWindow(windowId) });
                            if (!appWindow.isMaximized && !appWindow.isMinimized) mainItems.push({ label: 'Maximize', icon: 'fa-window-maximize', action: () => maximizeWindow(windowId) });
                            else if (appWindow.isMaximized) mainItems.push({ label: 'Restore', icon: 'fa-window-restore', action: () => restoreWindow(windowId) });
                            else if (appWindow.isMinimized) mainItems.push({ label: 'Restore & Focus', icon: 'fa-window-restore', action: () => restoreWindow(windowId) });
                            mainItems.push({ type: 'separator' });
                            mainItems.push({ label: 'Close', icon: 'fa-xmark', action: () => closeWindow(windowId) });
                        }
                    } else { mainItems.push({ label: 'Show Desktop', icon: 'fa-desktop', action: () => Object.keys(openWindows).forEach(id => minimizeWindow(id))}); }
                }

                if (showCustomMenu && (mainItems.length > 0 || smallItems.length > 0)) {
                    e.preventDefault(); customContextMenu.innerHTML = ''; const menuUl = document.createElement('ul');
                    mainItems.forEach(item => { const li = document.createElement('li'); if (item.type === 'separator') { li.className = 'context-menu-separator'; } else { li.className = 'context-menu-item'; li.innerHTML = `<i class="fa-solid ${item.icon}"></i> ${item.label}`; li.onclick = () => { item.action(); customContextMenu.classList.add('hidden'); }; } menuUl.appendChild(li); });
                    if (smallItems.length > 0) {
                        if (mainItems.length > 0 && mainItems[mainItems.length-1].type !== 'separator') menuUl.appendChild(Object.assign(document.createElement('li'), {className: 'context-menu-separator'}));
                        const smallItemRow = document.createElement('div'); smallItemRow.className = 'context-menu-small-item-row';
                        smallItems.forEach(item => { const btn = document.createElement('button'); btn.title = item.label; btn.innerHTML = `<i class="fa-solid ${item.icon}"></i><span>${item.label}</span>`; btn.onclick = () => { item.action(); customContextMenu.classList.add('hidden'); }; smallItemRow.appendChild(btn); });
                        menuUl.appendChild(smallItemRow);
                    }
                    if (menuUl.hasChildNodes()) {
                        customContextMenu.appendChild(menuUl);
                        const menuWidth = customContextMenu.offsetWidth; const menuHeight = customContextMenu.offsetHeight;
                        let x = isTouchEvent ? e.touches[0].clientX : e.clientX; let y = isTouchEvent ? e.touches[0].clientY : e.clientY;
                        if (x + menuWidth > window.innerWidth) x = window.innerWidth - menuWidth - 5; if (y + menuHeight > window.innerHeight) y = window.innerHeight - menuHeight - 5;
                        customContextMenu.style.left = `${Math.max(0, x)}px`; customContextMenu.style.top = `${Math.max(0, y)}px`;
                        customContextMenu.classList.remove('hidden');
                    }
                } else { customContextMenu.classList.add('hidden'); }
            }

            // --- Core Window Functions ---
            function createWindow(appId) {
                const appConfig = apps[appId];
                if (!appConfig) { console.error("App not found:", appId); showOSAlert(`The application "${appId}" could not be found.`, "App Error"); return; }
                const windowEl = document.createElement('div');
                windowEl.className = 'window'; windowEl.id = `window-${Date.now()}-${Math.random().toString(16).substring(2, 8)}`;
                const windowId = windowEl.id; 
                const openWindowCount = Object.keys(openWindows).length;
                const cascadeOffset = openWindowCount * 25; const initialX = 50 + cascadeOffset; const initialY = 50 + cascadeOffset;
                
                // --- MODIFICATION START: Prioritize app-defined size ---
                let currentW, currentH;
                if (appConfig.defaultSize && typeof appConfig.defaultSize.width === 'number' && typeof appConfig.defaultSize.height === 'number') {
                    currentW = appConfig.defaultSize.width;
                    currentH = appConfig.defaultSize.height;
                } else {
                    // Fallback to existing logic if defaultSize is not provided
                    currentW = 450; currentH = 350;
                    if (appId === 'Calculator') { currentW = 280; currentH = 450; } 
                    if (appId === 'TextPad') { currentW = 550; currentH = 400; } 
                    if (appId === 'Paint') { currentW = 650; currentH = 500; } 
                    if (appId === 'MediaPlayer') { currentW = 580; currentH = 400; } 
                    if (appId === 'Browser') { currentW = 700; currentH = 500; } 
                    if (appId === 'ImageViewer') { currentW = 600; currentH = 450; } 
                    if (appId === 'Settings') { currentW = 520; currentH = 480} 
                    if (appId === 'NotesApp') { currentW = 600; currentH = 450; } 
                    if (appId === 'AppInstaller') { currentW = 420; currentH = 500; }
					if (appId === 'VideoRecorder') { currentW = 450; currentH = 500; }
                }
                // --- MODIFICATION END ---

                 const maxInitialX = Math.max(0, desktop.clientWidth - currentW - 20); const maxInitialY = Math.max(0, desktop.clientHeight - currentH - 20);
                 windowEl.style.left = `${Math.min(initialX, maxInitialX)}px`; windowEl.style.top = `${Math.min(initialY, maxInitialY)}px`; windowEl.style.width = `${currentW}px`; windowEl.style.height = `${currentH}px`;
                 const titleIconHtml = getIconHtml(appConfig, 'small');
                 windowEl.innerHTML = `<div class="title-bar"><span class="title">${titleIconHtml} ${appConfig.name}</span><div class="window-controls"><button class="minimize-button" title="Minimize"><i class="fa-solid fa-window-minimize"></i></button><button class="maximize-button" title="Maximize"><i class="fa-solid fa-window-maximize"></i></button><button class="close-button" title="Close"><i class="fa-solid fa-xmark"></i></button></div></div><div class="window-content"></div>`;
                 const contentEl = windowEl.querySelector('.window-content'); const titleBar = windowEl.querySelector('.title-bar'); const minimizeButton = windowEl.querySelector('.minimize-button'); const maximizeButton = windowEl.querySelector('.maximize-button'); const closeButton = windowEl.querySelector('.close-button');
                 
                 let isDragging = false, isResizing = false, dragStartX, dragStartY, initialLeft, initialTop, initialWidth, initialHeight, currentTouchId = null;

                 const handleInteractionStart = (e) => {
                    const isTouch = e.type.startsWith('touch');
                    if (isTouch && e.touches.length > 1) return;
                    if (!isTouch && e.button !== 0) return;

                    const point = isTouch ? e.touches[0] : e;
                    const onControls = e.target.closest('.window-controls button');
                    if (onControls) return;

                    focusWindow(windowId);
                    
                    let localX, localY;
                    const rect = titleBar.getBoundingClientRect(); // Use titleBar rect for local coords
                    localX = point.clientX - rect.left;
                    localY = point.clientY - rect.top;

                    if (localX >= 0 && localX < 15 && localY >=0 && localY < 15 && !openWindows[windowId]?.isMaximized) {
                        isResizing = true;
                        windowEl.classList.add('resizing');
                    } else {
                        if(openWindows[windowId]?.isMaximized) return;
                        isDragging = true;
                        windowEl.classList.add('dragging');
                        titleBar.style.cursor = 'grabbing';
                    }

                    dragStartX = point.clientX;
                    dragStartY = point.clientY;
                    initialLeft = windowEl.offsetLeft;
                    initialTop = windowEl.offsetTop;
                    initialWidth = windowEl.offsetWidth;
                    initialHeight = windowEl.offsetHeight;

                    if (isTouch) currentTouchId = point.identifier;

                    document.addEventListener(isTouch ? 'touchmove' : 'mousemove', handleInteractionMove, { passive: !isTouch });
                    document.addEventListener(isTouch ? 'touchend' : 'mouseup', handleInteractionEnd);
                    document.addEventListener('touchcancel', handleInteractionEnd);
                    if(isTouch) e.preventDefault();
                 };

                 const handleInteractionMove = (e) => {
                    const isTouch = e.type.startsWith('touch');
                    let point;
                    if (isTouch) {
                        const touch = Array.from(e.changedTouches).find(t => t.identifier === currentTouchId);
                        if (!touch) return;
                        point = touch;
                    } else {
                        point = e;
                    }

                    const dx = point.clientX - dragStartX;
                    const dy = point.clientY - dragStartY;

                    if (isResizing) {
                        const newWidth = initialWidth - dx;
                        const newHeight = initialHeight - dy;
                        const minW = 200, minH = 150; // Get from CSS later if needed

                        if (newWidth > minW) {
                            windowEl.style.width = `${newWidth}px`;
                            windowEl.style.left = `${initialLeft + dx}px`;
                        }
                        if (newHeight > minH) {
                            windowEl.style.height = `${newHeight}px`;
                            windowEl.style.top = `${initialTop + dy}px`;
                        }
                    } else if (isDragging) {
                        const newLeft = Math.max(-windowEl.offsetWidth + 50, Math.min(desktop.clientWidth - 50, initialLeft + dx));
                        const newTop = Math.max(0, Math.min(desktop.clientHeight - 30, initialTop + dy));
                        windowEl.style.left = `${newLeft}px`;
                        windowEl.style.top = `${newTop}px`;
                    }
                 };

                 const handleInteractionEnd = (e) => {
                    const isTouch = e.type.startsWith('touch');
                     if (isTouch) {
                        if (currentTouchId === null) return;
                        const touch = Array.from(e.changedTouches).find(t => t.identifier === currentTouchId);
                        if (!touch && e.changedTouches.length > 0) {} else if (!touch) return;
                        currentTouchId = null;
                    }

                    if (isDragging) {
                        isDragging = false;
                        windowEl.classList.remove('dragging');
                        titleBar.style.cursor = 'grab';
                    }
                    if (isResizing) {
                        isResizing = false;
                        windowEl.classList.remove('resizing');
                    }
                    
                    document.removeEventListener(isTouch ? 'touchmove' : 'mousemove', handleInteractionMove);
                    document.removeEventListener(isTouch ? 'touchend' : 'mouseup', handleInteractionEnd);
                    document.removeEventListener('touchcancel', handleInteractionEnd);
                 };

                 titleBar.style.cursor = 'grab';
                 titleBar.addEventListener('mousedown', handleInteractionStart);
                 titleBar.addEventListener('touchstart', handleInteractionStart, { passive: false });
                 
                 closeButton.addEventListener('click', (e) => { e.stopPropagation(); closeWindow(windowId); });
                 minimizeButton.addEventListener('click', (e) => { e.stopPropagation(); minimizeWindow(windowId); });
                 maximizeButton.addEventListener('click', (e) => { e.stopPropagation(); if (openWindows[windowId]?.isMaximized) restoreWindow(windowId); else maximizeWindow(windowId); });
                titleBar.addEventListener('dblclick', (e) => { if (e.target.closest('.window-controls button')) return; if (openWindows[windowId]?.isMaximized) restoreWindow(windowId); else maximizeWindow(windowId); });
                let titleBarLongPressTimer = null; let titleBarTouchStartX = 0, titleBarTouchStartY = 0;
                titleBar.addEventListener('contextmenu', (e) => { handleContextMenu(e, false); });
                titleBar.addEventListener('touchstart', (e) => { if (e.target.closest('.window-controls button') || e.touches.length > 1) { clearTimeout(titleBarLongPressTimer); return; } const touch = e.touches[0]; titleBarTouchStartX = touch.clientX; titleBarTouchStartY = touch.clientY; clearTimeout(titleBarLongPressTimer); titleBarLongPressTimer = setTimeout(() => { if (!isDragging && !isResizing && !openWindows[windowId]?.isMaximized && localStorage.getItem(CONTEXT_MENU_ENABLED_KEY) !== 'false' && !osLocked) { handleContextMenu(e, true); } }, LONG_PRESS_DURATION); }, { passive: false });
                titleBar.addEventListener('touchmove', (e) => { if (titleBarLongPressTimer) { const touch = e.touches[0]; if (Math.abs(touch.clientX - touchStartX) > LONG_PRESS_MOVE_THRESHOLD || Math.abs(touch.clientY - touchStartY) > LONG_PRESS_MOVE_THRESHOLD) { clearTimeout(titleBarLongPressTimer); titleBarLongPressTimer = null; } } });
                titleBar.addEventListener('touchend', (e) => { clearTimeout(titleBarLongPressTimer); titleBarLongPressTimer = null; if (e.target.closest('.window-controls button')) return; const currentTime = new Date().getTime(); if (currentTime - lastTapTime < DOUBLE_TAP_THRESHOLD && e.target === lastTapTarget) { if (openWindows[windowId]?.isMaximized) restoreWindow(windowId); else maximizeWindow(windowId); lastTapTime = 0; } else { lastTapTime = currentTime; lastTapTarget = e.target; } });
                titleBar.addEventListener('touchcancel', () => { clearTimeout(titleBarLongPressTimer); titleBarLongPressTimer = null; });
                desktop.appendChild(windowEl);
                openWindows[windowId] = { element: windowEl, appId: appId, cleanup: null, isMinimized: false, isMaximized: false, savedPosition: null, savedSize: null };
                createTaskbarButton(windowId, appConfig.name, titleIconHtml);
                requestAnimationFrame(() => { try { appConfig.init(contentEl, windowId); } catch (initErr) { console.error(`Init err ${appId}:`, initErr); contentEl.innerHTML = `<p style="color:red;">Error initializing app: ${initErr.message}</p>`; } });
                focusWindow(windowId); adjustTaskbarHeight(); return windowId;
            }
            function focusWindow(windowId) { if (!openWindows[windowId] || activeWindowId === windowId) { if (openWindows[windowId]?.isMinimized) restoreWindow(windowId); return; } if (activeWindowId && openWindows[activeWindowId]) { openWindows[activeWindowId].element.classList.remove('active'); const oldBtn = document.getElementById(`taskbar-${activeWindowId}`); if(oldBtn) oldBtn.classList.remove('active'); } const windowEl = openWindows[windowId].element; windowEl.style.zIndex = nextZIndex++; windowEl.classList.add('active'); windowEl.classList.remove('minimized'); openWindows[windowId].isMinimized = false; const taskbarButton = document.getElementById(`taskbar-${windowId}`); if (taskbarButton) { taskbarButton.classList.add('active'); taskbarButton.classList.remove('minimized'); } activeWindowId = windowId; }
            function minimizeWindow(windowId) { const appWindow = openWindows[windowId]; if (!appWindow || appWindow.isMinimized) return; appWindow.element.classList.add('minimized'); appWindow.element.classList.remove('active'); appWindow.isMinimized = true; const btn = document.getElementById(`taskbar-${windowId}`); if (btn) { btn.classList.add('minimized'); btn.classList.remove('active'); } if (activeWindowId === windowId) activeWindowId = null; }
            function maximizeWindow(windowId) { const appWindow = openWindows[windowId]; if (!appWindow || appWindow.isMaximized) return; appWindow.savedPosition = { left: appWindow.element.style.left, top: appWindow.element.style.top }; appWindow.savedSize = { width: appWindow.element.style.width, height: appWindow.element.style.height }; appWindow.element.classList.add('maximized'); appWindow.element.style.resize = 'none'; appWindow.isMaximized = true; const maxBtn = appWindow.element.querySelector('.maximize-button'); if(maxBtn) { maxBtn.title="Restore"; maxBtn.innerHTML='<i class="fa-solid fa-window-restore"></i>'; } focusWindow(windowId); }
            function restoreWindow(windowId) { const appWindow = openWindows[windowId]; if (!appWindow) return; const wasMinimized = appWindow.isMinimized; const wasMaximized = appWindow.isMaximized; appWindow.element.classList.remove('minimized'); appWindow.isMinimized = false; if (wasMaximized && appWindow.savedPosition && appWindow.savedSize) { appWindow.element.classList.remove('maximized'); appWindow.element.style.left = appWindow.savedPosition.left; appWindow.element.style.top = appWindow.savedPosition.top; appWindow.element.style.width = appWindow.savedSize.width; appWindow.element.style.height = appWindow.savedSize.height; appWindow.element.style.resize = 'both'; appWindow.isMaximized = false; const maxBtn = appWindow.element.querySelector('.maximize-button'); if(maxBtn) { maxBtn.title="Maximize"; maxBtn.innerHTML='<i class="fa-solid fa-window-maximize"></i>'; } } else if (wasMaximized && !wasMinimized) { appWindow.element.classList.remove('maximized'); let restoreW = 450, restoreH = 350; if(appWindow.savedSize) { restoreW = parseInt(appWindow.savedSize.width) || restoreW; restoreH = parseInt(appWindow.savedSize.height) || restoreH; } appWindow.element.style.width = `${restoreW}px`; appWindow.element.style.height = `${restoreH}px`; appWindow.element.style.left = appWindow.savedPosition?.left || '50px'; appWindow.element.style.top = appWindow.savedPosition?.top || '50px'; appWindow.element.style.resize = 'both'; appWindow.isMaximized = false; const maxBtn = appWindow.element.querySelector('.maximize-button'); if(maxBtn) { maxBtn.title="Maximize"; maxBtn.innerHTML='<i class="fa-solid fa-window-maximize"></i>'; } } focusWindow(windowId); }
            function closeWindow(windowId) { const appWindow = openWindows[windowId]; if (!appWindow) return; if (appWindow.cleanup) { try { appWindow.cleanup(); } catch (err) { console.error(`Cleanup err ${appWindow.appId}:`, err); } } appWindow.element.remove(); removeTaskbarButton(windowId); delete openWindows[windowId]; if (activeWindowId === windowId) activeWindowId = null; adjustTaskbarHeight(); }
            function createTaskbarButton(windowId, appName, appIconHtml) { const button = document.createElement('button'); button.className = 'taskbar-app-button'; button.id = `taskbar-${windowId}`; button.innerHTML = `${appIconHtml} <span class="taskbar-app-name">${appName.substring(0, 15)}${appName.length > 15 ? '...' : ''}</span>`; button.title = appName; button.addEventListener('click', () => { if (activeWindowId === windowId && !openWindows[windowId]?.isMinimized) minimizeWindow(windowId); else restoreWindow(windowId); }); taskbarApps.appendChild(button); taskbarApps.scrollLeft = taskbarApps.scrollWidth; }
            function removeTaskbarButton(windowId) { const button = document.getElementById(`taskbar-${windowId}`); if (button) button.remove(); }
            function toggleStartMenu() { const isOpening = startMenu.classList.contains('hidden'); startMenu.classList.toggle('hidden'); if (isOpening && activeWindowId && openWindows[activeWindowId]) { openWindows[activeWindowId].element.classList.remove('active'); const btn = document.getElementById(`taskbar-${activeWindowId}`); if(btn) btn.classList.remove('active'); activeWindowId = null; } if (isOpening) { appSearchInput.focus(); } else { appSearchInput.value = ''; filterAppList(); } }
            function updateClock() { const now = new Date(); const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); const dateString = now.toLocaleDateString([], { weekday: 'short', month: 'short', day: 'numeric' }); clockElement.innerHTML = `${timeString}<br>${dateString}`; }

            // --- Desktop Shortcut Functions ---
            function createDesktopIconElement(appId, name, iconHtml) { const iconEl = document.createElement('div'); iconEl.className = 'desktop-icon'; iconEl.dataset.app = appId; iconEl.title = `Open ${name}`; iconEl.innerHTML = `${iconHtml} <span>${name}</span>`; desktop.appendChild(iconEl); return iconEl; }
            function addShortcutToDesktop(appId) { if (!apps[appId] || desktopShortcuts.includes(appId)) return; const appConfig = apps[appId]; createDesktopIconElement(appId, appConfig.name, getIconHtml(appConfig)); desktopShortcuts.push(appId); saveDesktopShortcuts(); populateAppList(); }
            function removeDesktopShortcut(appId) { const index = desktopShortcuts.indexOf(appId); if (index > -1) { desktopShortcuts.splice(index, 1); const iconEl = desktop.querySelector(`.desktop-icon[data-app="${appId}"]`); if (iconEl) iconEl.remove(); saveDesktopShortcuts(); populateAppList(); } }
            function loadDesktopShortcuts() { desktop.innerHTML = ''; const stored = localStorage.getItem(DESKTOP_SHORTCUTS_KEY); let loaded = []; if (stored) { try { const ids = JSON.parse(stored); if (Array.isArray(ids)) { ids.forEach(id => { const cfg = apps[id]; if (cfg) { createDesktopIconElement(id, cfg.name, getIconHtml(cfg)); loaded.push(id); } else console.warn(`Shortcut app ${id} not found.`); }); } } catch (e) { console.error("Load shortcuts err:", e); localStorage.removeItem(DESKTOP_SHORTCUTS_KEY); }} if (loaded.length === 0 && Object.keys(apps).length > 0) { const defaults = ['AppInstaller', 'NotesApp', 'Settings', 'Browser', 'MediaPlayer', 'Paint', 'Calculator', 'ImageViewer', 'ClockApp', 'TextPad', 'SoundRecorder', 'VideoRecorder']; defaults.forEach(id => { if (apps[id] && !loaded.includes(id)) { const cfg=apps[id]; createDesktopIconElement(id, cfg.name, getIconHtml(cfg)); loaded.push(id); }}); if (loaded.length > 0) { desktopShortcuts = loaded; saveDesktopShortcuts(); }} else { desktopShortcuts = loaded; if (stored && JSON.parse(stored).length !== loaded.length) saveDesktopShortcuts(); } }
            function saveDesktopShortcuts() { try { localStorage.setItem(DESKTOP_SHORTCUTS_KEY, JSON.stringify(desktopShortcuts)); } catch (e) { console.error("Save shortcuts err:", e); showOSAlert("An error occurred while trying to save your desktop shortcuts.", "Save Error"); } }

            // --- Background & Theme Functions ---
                        function applyMainTheme(stylesheetPath) {
                if (!stylesheetPath || !AVAILABLE_THEMES[stylesheetPath]) {
                    stylesheetPath = DEFAULT_THEME_STYLESHEET;
                }
                mainStylesheetLink.href = stylesheetPath;
                localStorage.setItem(THEME_STYLESHEET_KEY, stylesheetPath);

                // Give the CSS file a moment to load before re-reading CSS variables
                setTimeout(() => {
                    setDynamicDefaults();
                    // Re-apply all custom colors based on the new theme's defaults
                    const isLightTheme = getComputedStyle(document.documentElement).getPropertyValue('--theme-mode').trim() === 'light';
                    const customStartButtonBg = localStorage.getItem(START_BUTTON_BG_KEY);
                    if (customStartButtonBg) applyStartButtonColor(customStartButtonBg); else applyStartButtonColor(isLightTheme ? DEFAULT_START_BUTTON_BG_LIGHT : DEFAULT_START_BUTTON_BG_DARK);

                    // --- REVISED BACKGROUND LOGIC ---
                    // 1. Always establish a base gradient. Prioritize a stored custom gradient, otherwise use the theme's default.
                    const gradientColor1 = localStorage.getItem(BG_COLOR1_KEY) || (isLightTheme ? DEFAULT_BG_COLOR1_LIGHT : DEFAULT_BG_COLOR1) || '#2a2a2a';
                    const gradientColor2 = localStorage.getItem(BG_COLOR2_KEY) || (isLightTheme ? DEFAULT_BG_COLOR2_LIGHT : DEFAULT_BG_COLOR2) || '#1a1a1a';
                    applyGradientBackground(gradientColor1, gradientColor2);

                    // 2. Apply the wallpaper on top. If no wallpaper is saved in localStorage, default to the first one in the list.
                    const wallpaperUrl = localStorage.getItem(WALLPAPER_KEY);
                    if (wallpaperUrl) {
                        applyWallpaper(wallpaperUrl);
                    } else {
                        // On first load or after a clear, use the default wallpaper
                        applyWallpaper(DEFAULT_WALLPAPERS[0]);
                    }

                    // Re-apply all other custom color settings from storage
                    applyIconColor(localStorage.getItem(ICON_COLOR_KEY));
                    applyStartMenuIconColor(localStorage.getItem(START_MENU_ICON_COLOR_KEY));
                    applyWindowActiveBorderColor(localStorage.getItem(WINDOW_ACTIVE_BORDER_COLOR_KEY));
                    applyNonTransparentStyles(); // This is important to re-evaluate colors
                }, 200); // 200ms delay might be needed for slow connections/caching
            }
            function applyGradientBackground(color1, color2) { document.documentElement.style.setProperty('--bg-desktop-gradient', `linear-gradient(to bottom, ${color1}, ${color2})`); applyCombinedBackground(); const settingsWindow = Object.values(openWindows).find(w => w.appId === 'Settings'); if (settingsWindow?.element) { const sel = settingsWindow.element.querySelector('.wallpaper-selector'); sel?.querySelectorAll('img').forEach(img => img.classList.remove('active')); }}
            function saveGradientColors(color1, color2) { localStorage.setItem(BG_COLOR1_KEY, color1); localStorage.setItem(BG_COLOR2_KEY, color2); }
            function applyWallpaper(imageUrl) { document.documentElement.style.setProperty('--bg-desktop-image', imageUrl ? `url("${imageUrl}")` : 'none'); applyCombinedBackground(); if (imageUrl) { localStorage.removeItem(BG_COLOR1_KEY); localStorage.removeItem(BG_COLOR2_KEY); const settingsWindow = Object.values(openWindows).find(w => w.appId === 'Settings'); if (settingsWindow?.element) { const settingsWinId = settingsWindow.element.id; const c1Input = settingsWindow.element.querySelector(`#settings-bg-color1-${settingsWinId}`); const c2Input = settingsWindow.element.querySelector(`#settings-bg-color2-${settingsWinId}`); if(c1Input && DEFAULT_BG_COLOR1) c1Input.value = DEFAULT_BG_COLOR1; if(c2Input && DEFAULT_BG_COLOR2) c2Input.value = DEFAULT_BG_COLOR2; }}}
            function applyCombinedBackground() { const image = document.documentElement.style.getPropertyValue('--bg-desktop-image'); const gradient = document.documentElement.style.getPropertyValue('--bg-desktop-gradient'); document.documentElement.style.setProperty('--bg-desktop', `${image && image !== 'none' ? image + ',' : ''} ${gradient}`);}
            function applyAnimationSetting(isDisabled) { document.body.classList.toggle('animations-disabled', isDisabled); }
            function applyIconColor(color) { if (color) document.documentElement.style.setProperty('--text-desktop-icons', color); else document.documentElement.style.setProperty('--text-desktop-icons', getComputedStyle(document.documentElement).getPropertyValue('--text-desktop-icons-dark').trim()); }
            function applyStartButtonColor(color) { if (color) { document.documentElement.style.setProperty('--start-button-bg', color); const hoverColor = tinycolor(color).isDark() ? tinycolor(color).lighten(10).toString() : tinycolor(color).darken(10).toString(); document.documentElement.style.setProperty('--start-button-hover-bg', hoverColor); } else { document.documentElement.style.setProperty('--start-button-bg', getComputedStyle(document.documentElement).getPropertyValue('--start-button-bg-dark').trim()); document.documentElement.style.setProperty('--start-button-hover-bg', tinycolor(getComputedStyle(document.documentElement).getPropertyValue('--start-button-bg-dark').trim()).lighten(10).toString()); }}
            function applyStartMenuIconColor(color) { if (color) document.documentElement.style.setProperty('--start-menu-icon-color', color); else document.documentElement.style.setProperty('--start-menu-icon-color', getComputedStyle(document.documentElement).getPropertyValue('--start-menu-icon-color-dark').trim()); }
            function applyWindowActiveBorderColor(color) { if (color) { document.documentElement.style.setProperty('--window-active-border-color-custom', color); } else { document.documentElement.style.removeProperty('--window-active-border-color-custom'); } applyNonTransparentStyles(); }
            function applyNonTransparentStyles() { const taskbarUserColor = localStorage.getItem(TASKBAR_COLOR_KEY) || getComputedStyle(document.documentElement).getPropertyValue('--taskbar-bg-dark').trim(); document.documentElement.style.setProperty('--taskbar-bg', taskbarUserColor); document.documentElement.style.setProperty('--border-primary', `var(--border-primary-dark)`); document.documentElement.style.setProperty('--border-secondary', `var(--border-secondary-dark)`); let activeBorderColorSource = localStorage.getItem(WINDOW_ACTIVE_BORDER_COLOR_KEY) || getComputedStyle(document.documentElement).getPropertyValue('--window-active-border-color-default-dark').trim(); document.documentElement.style.setProperty('--border-active', activeBorderColorSource); }
            function applyWindowGlowSetting(enabled) { document.body.classList.toggle('window-glow-active', enabled); }
            function applyWindowGlowSpeed(speed) { document.documentElement.style.setProperty('--window-glow-blink-speed', `${speed}s`); }
            function applyStartButtonGlow(enabled) { startButton.classList.toggle('blinking-glow-enabled', enabled); }
            function applyCustomCSS(cssContent, filename) { let customStyleTag = document.getElementById('custom-os-stylesheet'); if (!customStyleTag) { customStyleTag = document.createElement('style'); customStyleTag.id = 'custom-os-stylesheet'; document.head.appendChild(customStyleTag); } customStyleTag.innerHTML = cssContent; console.log(`Applied custom CSS: ${filename}`); }
            function removeCustomCSS() { const customStyleTag = document.getElementById('custom-os-stylesheet'); if (customStyleTag) { customStyleTag.remove(); console.log("Custom CSS removed."); } }
            function applyDesktopIconsVisibility(visible) { desktop.classList.toggle('icons-hidden', !visible); if (!document.body.classList.contains('animations-disabled')) {} else { const icons = desktop.querySelectorAll('.desktop-icon'); icons.forEach(icon => { icon.style.display = visible ? '' : 'none'; }); } }
            function applyDesktopIconArrangement(arrangement) { desktop.style.gridAutoFlow = arrangement; }

            async function handleClearCacheAndReset() {
                const confirm1 = await showOSDialog({
                    title: '⚠️ DESTRUCTIVE ACTION ⚠️',
                    message: "This will permanently delete ALL Simplex OS data stored in your browser for this site, including installed apps, desktop shortcuts, notes, custom settings, and any saved OS lock screen password.\n\nThis action is IRREVERSIBLE.\n\nAre you absolutely sure you want to proceed?",
                    buttons: [{label: 'Cancel', value: false}, {label: 'Yes, I understand', value: true, class: 'danger'}]
                });
                if (!confirm1) return;
                const confirmText = "DELETE ALL MY DATA";
                const confirm2 = await showOSPrompt(`To confirm this irreversible action, please type EXACTLY:\n\n"${confirmText}"`, "Final Confirmation", "", "text");
                if (confirm2 === confirmText) {
                    try { localStorage.clear(); await showOSAlert("All Simplex OS data has been cleared. The OS will now reload."); window.location.reload(); }
                    catch (e) { await showOSAlert("An error occurred while trying to clear data. Please try clearing your browser's site data manually for this page."); console.error("Error clearing localStorage:", e); }
                } else { await showOSAlert("The confirmation text did not match. The reset operation has been cancelled.", "Reset Cancelled"); }
            }

            function setDynamicDefaults() {
                const styles = getComputedStyle(document.documentElement);
                DEFAULT_BG_COLOR1 = styles.getPropertyValue('--bg-desktop-color1-default').trim(); 
                DEFAULT_BG_COLOR2 = styles.getPropertyValue('--bg-desktop-color2-default').trim();
                DEFAULT_ICON_COLOR_DARK = styles.getPropertyValue('--text-desktop-icons-dark').trim(); 
                DEFAULT_START_BUTTON_BG_DARK = styles.getPropertyValue('--start-button-bg-dark').trim();
                DEFAULT_START_MENU_ICON_COLOR_DARK = styles.getPropertyValue('--start-menu-icon-color-dark').trim(); 
                DEFAULT_WINDOW_ACTIVE_BORDER_DARK = styles.getPropertyValue('--window-active-border-color-default-dark').trim();
                DEFAULT_BORDER_PRIMARY_DARK = styles.getPropertyValue('--border-primary-dark').trim(); 
                DEFAULT_BORDER_SECONDARY_DARK = styles.getPropertyValue('--border-secondary-dark').trim();
                DEFAULT_TASKBAR_BG_DARK = styles.getPropertyValue('--taskbar-bg-dark').trim();
            }

            function loadAndApplyInitialSettings() {
                const savedTheme = localStorage.getItem(THEME_STYLESHEET_KEY) || DEFAULT_THEME_STYLESHEET;
                applyMainTheme(savedTheme); // This now handles defaults and re-application
                
                // Other settings that are not theme-dependent or are applied after the theme loads
                applyAnimationSetting(localStorage.getItem(ANIMATIONS_DISABLED_KEY) === 'true');
                const windowGlowEnabled = localStorage.getItem(WINDOW_GLOW_ENABLED_KEY) === 'true'; applyWindowGlowSetting(windowGlowEnabled);
                if (windowGlowEnabled) { const windowGlowSpeed = parseFloat(localStorage.getItem(WINDOW_GLOW_SPEED_KEY)) || 1.5; applyWindowGlowSpeed(windowGlowSpeed); }
                applyStartButtonGlow(localStorage.getItem(START_BUTTON_GLOW_ENABLED_KEY) === 'true');
                const storedCustomCSS = localStorage.getItem(CUSTOM_CSS_CONTENT_KEY); const storedCustomCSSFilename = localStorage.getItem(CUSTOM_CSS_FILENAME_KEY);
                if (storedCustomCSS) { applyCustomCSS(storedCustomCSS, storedCustomCSSFilename); }
                desktopIconsVisible = localStorage.getItem(DESKTOP_ICONS_VISIBLE_KEY) !== 'false'; applyDesktopIconsVisibility(desktopIconsVisible);
                desktopIconArrangement = localStorage.getItem(DESKTOP_ICON_ARRANGEMENT_KEY) || DEFAULT_DESKTOP_ICON_ARRANGEMENT; applyDesktopIconArrangement(desktopIconArrangement);
            }

                        function applyThemePreset(presetName) {
                let mainColor, iconContrastingColor, wallpaperPath;

                // --- 1. Determine settings based on preset ---
                switch(presetName) { 
                    case 'blue': 
                        mainColor = '#0078D4'; iconContrastingColor = '#FFFFFF'; wallpaperPath = DEFAULT_WALLPAPERS[0];
                        break; 
                    case 'red': 
                        mainColor = '#D32F2F'; iconContrastingColor = '#FFFFFF'; wallpaperPath = DEFAULT_WALLPAPERS[1];
                        break; 
                    case 'green': 
                        mainColor = '#388E3C'; iconContrastingColor = '#FFFFFF'; wallpaperPath = DEFAULT_WALLPAPERS[2];
                        break;
                    case 'orange': 
                        mainColor = '#F57C00'; iconContrastingColor = '#FFFFFF'; wallpaperPath = DEFAULT_WALLPAPERS[3];
                        break; 
                    case 'dark_grey': 
                        mainColor = '#424242'; iconContrastingColor = '#FFFFFF'; wallpaperPath = DEFAULT_WALLPAPERS[4];
                        break; 
                    default: return; 
                }
                
                // --- 2. Apply and save all new settings ---
                // Color settings
                applyStartButtonColor(mainColor); localStorage.setItem(START_BUTTON_BG_KEY, mainColor);
                applyStartMenuIconColor(iconContrastingColor); localStorage.setItem(START_MENU_ICON_COLOR_KEY, iconContrastingColor);
                applyIconColor(iconContrastingColor); localStorage.setItem(ICON_COLOR_KEY, iconContrastingColor);
                applyWindowActiveBorderColor(mainColor); localStorage.setItem(WINDOW_ACTIVE_BORDER_COLOR_KEY, mainColor);
                localStorage.setItem(TASKBAR_COLOR_KEY, DEFAULT_TASKBAR_BG_DARK); 
                
                // Wallpaper setting
                if (wallpaperPath) {
                    applyWallpaper(wallpaperPath);
                    localStorage.setItem(WALLPAPER_KEY, wallpaperPath);
                    // Note: applyWallpaper already clears gradient colors from localStorage
                }
                
                // This re-evaluates taskbar color and active border based on new/old settings
                applyNonTransparentStyles();
                
                // --- 3. Refresh the Settings window UI to show the changes ---
                const settingsWin = Object.values(openWindows).find(w => w.appId === 'Settings' && w.element);
                if (settingsWin) { 
                    try { 
                        const settingsApp = settingsWin.element.querySelector('.settings-app'); 
                        if (settingsApp && typeof settingsApp._loadCurrentSettings === 'function') {
                            // This function is defined on the settings app element and will reload all its input values
                            // from localStorage, including the new wallpaper selection and color picker values.
                            settingsApp._loadCurrentSettings(); 
                        }
                    } catch(e) { 
                        console.error("Error updating settings pickers after preset:", e); 
                    }
                }
            }

            function applyStartMenuView(viewType) { startMenu.classList.remove('list-view', 'grid-view'); if (viewType === 'grid') startMenu.classList.add('grid-view'); else startMenu.classList.add('list-view'); }
            function loadAndApplyStartMenuView() { const savedView = localStorage.getItem(STARTMENU_VIEW_KEY) || DEFAULT_STARTMENU_VIEW; applyStartMenuView(savedView); }

            function populateAppList() {
                appList.innerHTML = ''; const currentView = startMenu.classList.contains('grid-view') ? 'grid' : 'list'; const iconSize = currentView === 'grid' ? 'large' : 'small';
                const sortedAppIds = Object.keys(apps).sort((a, b) => apps[a].name.toLowerCase().localeCompare(apps[b].name.toLowerCase()));
                sortedAppIds.forEach(appId => {
                    const appConfig = apps[appId]; const li = document.createElement('li'); li.dataset.appName = appConfig.name; const appInfo = document.createElement('div'); appInfo.className = 'app-info'; appInfo.title = `Launch ${appConfig.name}`; appInfo.innerHTML = `<span class="icon">${getIconHtml(appConfig, iconSize)}</span> <span class="app-name">${appConfig.name}</span>`; appInfo.onclick = () => { createWindow(appId); toggleStartMenu(); }; li.appendChild(appInfo);
                    const actionsDiv = document.createElement('div'); actionsDiv.className = 'app-actions'; const hasShortcut = desktopShortcuts.includes(appId); const shortcutBtn = document.createElement('button'); shortcutBtn.dataset.appId = appId; shortcutBtn.onclick = (e) => { e.stopPropagation(); const id = e.currentTarget.dataset.appId; const currentlyHasShortcut = desktopShortcuts.includes(id); if (currentlyHasShortcut) removeDesktopShortcut(id); else addShortcutToDesktop(id); }; shortcutBtn.className = hasShortcut ? 'remove-shortcut-button' : 'add-shortcut-button'; shortcutBtn.innerHTML = hasShortcut ? '<i class="fa-solid fa-minus"></i>' : '<i class="fa-solid fa-thumbtack"></i>'; shortcutBtn.title = hasShortcut ? `Remove shortcut` : `Add shortcut`; actionsDiv.appendChild(shortcutBtn);
                    if (appConfig.isCustom) { const uninstallBtn = document.createElement('button'); uninstallBtn.className = 'uninstall-button'; uninstallBtn.innerHTML = '<i class="fa-solid fa-trash-can"></i>'; uninstallBtn.title = `Uninstall`; uninstallBtn.dataset.appId = appId; uninstallBtn.onclick = (e) => { e.stopPropagation(); uninstallApp(e.currentTarget.dataset.appId); }; actionsDiv.appendChild(uninstallBtn); }
                    li.appendChild(actionsDiv); appList.appendChild(li);
                });
            }

            function filterAppList() {
                const searchTerm = appSearchInput.value.toLowerCase();
                const items = appList.getElementsByTagName('li');
                for (let i = 0; i < items.length; i++) {
                    const appName = items[i].dataset.appName.toLowerCase();
                    if (appName.includes(searchTerm)) {
                        items[i].style.display = '';
                    } else {
                        items[i].style.display = 'none';
                    }
                }
            }

            function loadInstalledApps() { const stored = localStorage.getItem(INSTALLED_APPS_STORAGE_KEY); if (stored) { try { const loaded = JSON.parse(stored); if (typeof loaded === 'object' && loaded !== null) { for (const id in loaded) { if (loaded.hasOwnProperty(id) && !apps[id]) { try { const data = loaded[id]; if(typeof data === 'object' && data.name && data.initCode) { apps[id] = { name: data.name, icon: data.icon || '<i class="fa-solid fa-puzzle-piece"></i>', iconPath: data.iconPath || null, isCustom: true, init: new Function('contentEl', 'windowId', data.initCode), defaultSize: data.defaultSize || null }; } else console.warn(`Invalid app data for ${id}`); } catch (err) { console.error(`Error recreating func for ${id}:`, err); }}}}} catch (e) { console.error("Load installed err:", e); localStorage.removeItem(INSTALLED_APPS_STORAGE_KEY); }} }
            function saveInstalledApps() { const toSave = {}; for (const id in apps) { if (apps[id].isCustom) { try { const funcString = apps[id].init.toString(); const bodyMatch = funcString.match(/^(?:async\s*)?function\s*?\w*?\s*?\([^)]*\)\s*?\{([\s\S]*)\}$/); if (bodyMatch && bodyMatch[1]) { toSave[id] = { name: apps[id].name, icon: apps[id].icon, iconPath: apps[id].iconPath, initCode: bodyMatch[1].trim(), defaultSize: apps[id].defaultSize || null }; } else { console.error(`Could not extract function body for ${id}`); } } catch(e){ console.error(`Failed to stringify init for ${id}`, e);}}} try { localStorage.setItem(INSTALLED_APPS_STORAGE_KEY, JSON.stringify(toSave)); } catch(e) { console.error("Save installed err:", e); showOSAlert("Failed to save the list of installed applications.", "Save Error"); } }
            async function uninstallApp(appId) { const appName = apps[appId]?.name; if (!apps[appId]?.isCustom || !appName) { await showOSAlert("Cannot uninstall built-in or missing applications.", "Uninstall Error"); return; } if (await showOSConfirmDanger(`Are you sure you want to uninstall "${appName}"?`, "Uninstall App")) { Object.keys(openWindows).forEach(winId => { if (openWindows[winId].appId === appId) closeWindow(winId); }); removeDesktopShortcut(appId); delete apps[appId]; saveInstalledApps(); populateAppList(); Object.keys(openWindows).forEach(winId => { if (openWindows[winId].appId === 'AppInstaller' && openWindows[winId].element) { const installerAppEl = openWindows[winId].element.querySelector('.app-installer-app'); if(installerAppEl && typeof installerAppEl._populateList === 'function') { try { installerAppEl._populateList(); } catch (e) { console.error("Error repopulating installer list:", e); }}}}); await showOSAlert(`The app "${appName}" has been uninstalled.`, "Uninstall Complete"); }}

            let clockPopupVisible = false; let taskbarPopupInterval = null;
            function updateTaskbarPopupTimeDate() { const now = new Date(); const timeEl = taskbarClockPopup.querySelector('.popup-time'); const dateEl = taskbarClockPopup.querySelector('.popup-date'); if (timeEl) timeEl.textContent = now.toLocaleTimeString(); if (dateEl) dateEl.textContent = now.toLocaleDateString(undefined, { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }); }
            function showClockPopup() { if (clockPopupVisible) return; updateTaskbarPopupTimeDate(); const clockRect = clockElement.getBoundingClientRect(); taskbarClockPopup.style.bottom = `45px`; taskbarClockPopup.style.right = `${document.documentElement.clientWidth - clockRect.right}px`; taskbarClockPopup.style.display = 'block'; clockPopupVisible = true; if (taskbarPopupInterval) clearInterval(taskbarPopupInterval); taskbarPopupInterval = setInterval(updateTaskbarPopupTimeDate, 1000); }
            function hideClockPopup() { if (!clockPopupVisible) return; taskbarClockPopup.style.display = 'none'; clockPopupVisible = false; if (taskbarPopupInterval) { clearInterval(taskbarPopupInterval); taskbarPopupInterval = null; } }

            const tinycolor = (color) => { try { const hexToRgbArray = (hex) => { hex = hex.replace(/^#/, ''); if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2]; let bigint = parseInt(hex, 16); return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255]; }; const rgbArrayToHsl = (rgb) => { let r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255; let max = Math.max(r, g, b), min = Math.min(r, g, b); let h, s, l = (max + min) / 2; if (max === min) { h = s = 0; } else { let d = max - min; s = l > 0.5 ? d / (2 - max - min) : d / (max + min); switch (max) { case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break;} h /= 6;} return [h, s, l]; }; const hslToHex = (h, s, l) => { let r, g, b; if (s === 0) { r = g = b = l; } else { const hue2rgb = (p, q, t) => { if (t < 0) t += 1; if (t > 1) t -= 1; if (t < 1/6) return p + (q - p) * 6 * t; if (t < 1/2) return q; if (t < 2/3) return p + (q - p) * (2/3 - t) * 6; return p; }; let q = l < 0.5 ? l * (1 + s) : l + s - l * s; let p = 2 * l - q; r = hue2rgb(p, q, h + 1/3); g = hue2rgb(p, q, h); b = hue2rgb(p, q, h - 1/3); } const toHex = x => Math.round(x * 255).toString(16).padStart(2, '0'); return `#${toHex(r)}${toHex(g)}${toHex(b)}`; }; const rgb = hexToRgbArray(color); const isDark = (rgb[0] * 0.299 + rgb[1] * 0.587 + rgb[2] * 0.114) < 140; return { isDark: () => isDark, lighten: (amount) => { let [h, s, l] = rgbArrayToHsl(rgb); l += amount / 100; l = Math.min(1, Math.max(0, l)); return hslToHex(h, s, l); }, darken: (amount) => { let [h, s, l] = rgbArrayToHsl(rgb); l -= amount / 100; l = Math.min(1, Math.max(0, l)); return hslToHex(h, s, l); }, toString: () => color }; } catch (e) { console.warn("TinyColor failed for:", color, e); return { isDark: () => true, lighten: () => color, darken: () => color, toString: () => color }; }};

            function initializeMainOS() {
                loadInstalledApps(); 
                loadAndApplyInitialSettings(); 
                loadAndApplyStartMenuView(); 
                loadDesktopShortcuts(); 
                loadDesktopWidgets(); 
                populateAppList(); 
                updateClock(); 
                setInterval(updateClock, 1000 * 30); 
                createContextMenuElement();
                
                appSearchInput.addEventListener('input', filterAppList);
                desktop.addEventListener('contextmenu', (e) => handleContextMenu(e, false));
                taskbar.addEventListener('contextmenu', (e) => handleContextMenu(e, false));
                startMenu.addEventListener('contextmenu', (e) => handleContextMenu(e, false));
                desktop.addEventListener('touchstart', (e) => { if (e.touches.length > 1) { clearTimeout(longPressTimer); return; } const touch = e.touches[0]; touchStartX = touch.clientX; touchStartY = touch.clientY; clearTimeout(longPressTimer); longPressTimer = setTimeout(() => { if (e.target.closest('.desktop-icon') || (e.target.id === 'desktop' && !e.target.closest('.desktop-widget'))) { if (localStorage.getItem(CONTEXT_MENU_ENABLED_KEY) !== 'false' && !osLocked) { handleContextMenu(e, true); } } }, LONG_PRESS_DURATION); }, { passive: false });
                const clearLongPressMoveCheck = (e) => { if (longPressTimer) { const touch = e.touches[0]; if (Math.abs(touch.clientX - touchStartX) > LONG_PRESS_MOVE_THRESHOLD || Math.abs(touch.clientY - touchStartY) > LONG_PRESS_MOVE_THRESHOLD) { clearTimeout(longPressTimer); longPressTimer = null; } } };
                const clearLongPressEnd = () => { clearTimeout(longPressTimer); longPressTimer = null; };
                desktop.addEventListener('touchmove', clearLongPressMoveCheck, { passive: true }); desktop.addEventListener('touchend', clearLongPressEnd); desktop.addEventListener('touchcancel', clearLongPressEnd);
                clockElement.addEventListener('click', (e) => { e.stopPropagation(); if (clockPopupVisible) hideClockPopup(); else showClockPopup(); });
                if (typeof ResizeObserver !== 'undefined') { const taskbarAppsObserver = new ResizeObserver(adjustTaskbarHeight); taskbarAppsObserver.observe(taskbarApps); const taskbarAppsMutationObserver = new MutationObserver(adjustTaskbarHeight); taskbarAppsMutationObserver.observe(taskbarApps, { childList: true }); } else { setInterval(adjustTaskbarHeight, 1000); }
                adjustTaskbarHeight(); startButton.addEventListener('click', (e) => { e.stopPropagation(); toggleStartMenu(); });
                desktop.addEventListener('dblclick', (e) => { const iconDiv = e.target.closest('.desktop-icon'); if (iconDiv && iconDiv.dataset.app && !e.target.matches('.desktop-icon > span:last-child')) { createWindow(iconDiv.dataset.app); } });
                desktop.addEventListener('touchend', (e) => { const iconDiv = e.target.closest('.desktop-icon'); if (iconDiv && iconDiv.dataset.app && !e.target.matches('.desktop-icon > span:last-child')) { const currentTime = new Date().getTime(); if (currentTime - lastTapTime < DOUBLE_TAP_THRESHOLD && iconDiv === lastTapTarget) { createWindow(iconDiv.dataset.app); lastTapTime = 0; } else { lastTapTime = currentTime; lastTapTarget = iconDiv; } } });
                document.addEventListener('mousedown', (e) => { if (osLocked) return; const clickedWindow = e.target.closest('.window'); const clickedStartButton = e.target.closest('#start-button'); const clickedStartMenu = e.target.closest('#start-menu'); const clickedTaskbarClock = e.target.closest('#clock'); const clickedClockPopup = e.target.closest('#taskbar-clock-popup'); const clickedTaskbarApp = e.target.closest('#taskbar-apps button'); const clickedContextMenuEl = e.target.closest('#custom-context-menu'); const clickedDialog = e.target.closest('#os-dialog-overlay'); if (!startMenu.classList.contains('hidden') && !clickedStartButton && !clickedStartMenu && !clickedContextMenuEl && !clickedDialog) { toggleStartMenu(); } if (clockPopupVisible && !clickedTaskbarClock && !clickedClockPopup && !clickedContextMenuEl && !clickedDialog) { hideClockPopup(); } if (clickedWindow) { if (clickedWindow.id && clickedWindow.id !== activeWindowId) { focusWindow(clickedWindow.id); } } else if (!clickedStartButton && !clickedStartMenu && !clickedTaskbarClock && !clickedClockPopup && !clickedTaskbarApp && !clickedContextMenuEl && !clickedDialog) { if (activeWindowId && openWindows[activeWindowId]) { openWindows[activeWindowId].element.classList.remove('active'); const taskbarButton = document.getElementById(`taskbar-${activeWindowId}`); if (taskbarButton) taskbarButton.classList.remove('active'); activeWindowId = null; } } }, true);
                document.addEventListener('touchstart', (e) => { if (osLocked) return; const clickedStartButton = e.target.closest('#start-button'); const clickedStartMenu = e.target.closest('#start-menu'); const clickedTaskbarClock = e.target.closest('#clock'); const clickedClockPopup = e.target.closest('#taskbar-clock-popup'); const clickedContextMenuEl = e.target.closest('#custom-context-menu'); const clickedDialog = e.target.closest('#os-dialog-overlay'); if (!startMenu.classList.contains('hidden') && !clickedStartButton && !clickedStartMenu && !clickedContextMenuEl && !clickedDialog) { toggleStartMenu(); } if (clockPopupVisible && !clickedTaskbarClock && !clickedClockPopup && !clickedContextMenuEl && !clickedDialog) { hideClockPopup(); } }, { passive: true, capture: true });

            window.addEventListener('message', async (event) => {
                const currentOsOrigin = window.location.origin;
                const currentOsProtocol = window.location.protocol;
                let originIsValid = false;

                if (currentOsProtocol === 'file:') {
                    if (event.origin === 'file://' || event.origin === null || String(event.origin) === "null") {
                        originIsValid = true;
                    }
                } else {
                    if (event.origin === currentOsOrigin) {
                        originIsValid = true;
                    }
                }
                
                if (!originIsValid) {
                    console.warn("Message from untrusted origin:", event.origin, ". Expected:", currentOsOrigin);
                    return;
                }

                if (event.data && event.data.type === 'installAppFromLibrary') {
                    const { name, code, icon } = event.data;

                    const confirmed = await showOSConfirmDanger(`Install "${name}" from the App Library?\n\n⚠️ SECURITY RISK ⚠️\nThis will execute code directly from the library. Only install from trusted sources.\n\nProceed?`, "Install Confirmation");

                    if (!confirmed) {
                        await showOSAlert("Installation cancelled by user.", "Cancelled");
                        return;
                    }

                    try {
                        const tempScript = document.createElement('script');
                        tempScript.textContent = code;
                        document.body.appendChild(tempScript);

                        if (typeof window.simplexOS_AppConfig === 'object' && window.simplexOS_AppConfig !== null && typeof window.simplexOS_AppConfig.init === 'function') {
                            const libraryAppConfig = window.simplexOS_AppConfig;
                            const appId = `custom-${libraryAppConfig.name.replace(/\s+/g, '_')}-${Date.now()}`;

                            apps[appId] = {
                                name: libraryAppConfig.name,
                                icon: libraryAppConfig.icon || icon || '<i class="fa-solid fa-puzzle-piece"></i>',
                                iconPath: libraryAppConfig.iconPath || null,
                                isCustom: true,
                                init: libraryAppConfig.init,
                                defaultSize: libraryAppConfig.defaultSize || null
                            };
                            
                            delete window.simplexOS_AppConfig;
                            tempScript.remove();
                            
                            saveInstalledApps();
                            populateAppList();
                            
                            const installerWindow = Object.values(openWindows).find(w => w.appId === 'AppInstaller' && w.element);
                            if (installerWindow) {
                                const installerAppEl = installerWindow.element.querySelector('.app-installer-app');
                                if (installerAppEl && typeof installerAppEl._populateList === 'function') {
                                    try {
                                       installerAppEl._populateList();
                                    } catch(e) { console.error("Error repopulating installer list:", e); }
                                }
                            }
                            
                            await showOSAlert(`App "${libraryAppConfig.name}" has been installed successfully!`, "Installation Complete");
                        } else {
                            tempScript.remove();
                            delete window.simplexOS_AppConfig;
                            throw new Error("The app's structure from the library is invalid or 'simplexOS_AppConfig' was not found.");
                        }
                    } catch (err) {
                        await showOSAlert(`An error occurred while installing "${name}" from the library:\n\n${err.message}`, "Installation Error");
                        console.error("Error processing app from library:", err);
                    }
                }
            });            
        }

/**
 * =============================================================================
 * Simplex OS App Development Guide
 * =============================================================================
 *
 * This guide explains how to create custom JavaScript applications for Simplex OS.
 *
 * --- 1. The `simplexOS_AppConfig` Object ---
 * Your app's `.js` file must define a global variable named `simplexOS_AppConfig`.
 * This object tells the OS how to load your app. It must contain:
 * - `name` (String): The display name of your app (e.g., "Pixel Art Editor").
 * - `icon` (String): An HTML string for the icon, typically from Font Awesome
 *   (e.g., '<i class="fa-solid fa-palette"></i>').
 * - `init` (Function): The main function that initializes your app. It receives
 *   two arguments: `contentEl` (the window's content area HTMLElement) and
 *   `windowId` (a unique ID for that window instance).
 * - `defaultSize` (Object, Optional): Defines the default window size.
 *   - `width` (Number): The default width in pixels.
 *   - `height` (Number): The default height in pixels.
 *
 * --- 2. The `init` Function In-Depth ---
 * - **Rendering UI**: The most common method is to set the `innerHTML` of the
 *   `contentEl` with your app's HTML structure.
 * - **Unique IDs**: Use the `windowId` to create unique IDs for your app's
 *   elements (e.g., `id="my-button-${windowId}"`) to prevent conflicts when
 *   multiple instances of your app are open.
 * - **Styling**: You can add a `<style>` tag to `contentEl` or `document.head`.
 *   Use OS theme variables (e.g., `var(--bg-primary)`) for a consistent look.
 * - **Event Handling**: After setting `innerHTML`, get references to your
 *   elements using `contentEl.querySelector()` and attach event listeners.
 * - **Cleanup**: If your app uses timers (`setInterval`) or global listeners,
 *   provide a cleanup function to prevent memory leaks. The OS will call this
 *   when the window is closed:
 *   `if (window.openWindows && window.openWindows[windowId]) {`
 *   `  window.openWindows[windowId].cleanup = () => { clearInterval(myTimer); };`
 *   `}`
 *
 * --- 3. Example App Structure ---
 * ```javascript
 * // MyCoolApp.js
 * var simplexOS_AppConfig = {
 *   name: "My Cool App",
 *   icon: '<i class="fa-solid fa-rocket"></i>',
 *   defaultSize: { width: 400, height: 300 }, // <-- NEW
 *   init: function(contentEl, windowId) {
 *     const appPrefix = `my-app-${windowId}`;
 *     contentEl.innerHTML = `
 *       <div id="${appPrefix}-container" style="padding:10px;">
 *         <h3>Welcome to ${this.name}!</h3>
 *         <button id="${appPrefix}-button">Click Me</button>
 *       </div>`;
 *
 *     const button = contentEl.querySelector(`#${appPrefix}-button`);
 *     button.addEventListener('click', () => {
 *       // Use the OS dialog system instead of alert()
 *       window.showOSAlert("Hello from " + this.name, "Greeting");
 *     });
 *
 *     console.log(this.name + " initialized for window: " + windowId);
 *   }
 * };
 * ```
 *
 * --- 4. Installation ---
 * - Save your code as a `.js` file.
 * - In Simplex OS, open the "App Installer".
 * - Click "Install from .js File..." or visit the App Library.
 * - A security confirmation will appear. Only install trusted code.
 *
 * ---END OF GUIDE---
 */

            // --- Start the OS ---
            console.log("Simplex OS Booting...");
            checkLockState();

        }); // End DOMContentLoaded
    </script>
</body>
</html>
