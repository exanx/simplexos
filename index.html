'Paint': {
    name: 'Paint',
    icon: '<i class="fa-solid fa-paintbrush"></i>',
    isCustom: false,
    defaultSize: { width: 750, height: 550 },
    init: (contentEl, windowId) => {
        contentEl.style.padding = '0';
        contentEl.style.overflow = 'hidden';

        contentEl.innerHTML = `
        <div class="paint-app-container">
            <div class="paint-toolbar top-toolbar">
                <button id="save-paint-${windowId}" title="Save Image"><i class="fa-solid fa-save"></i> Save</button>
                <button id="resize-canvas-${windowId}" title="Resize Canvas"><i class="fa-solid fa-arrows-up-down-left-right"></i> Resize</button>
                <button id="clear-canvas-${windowId}" title="Clear Canvas"><i class="fa-solid fa-trash-can"></i> Clear</button>
                <div class="separator"></div>
                <button id="undo-${windowId}" title="Undo (Ctrl+Z)" disabled><i class="fa-solid fa-undo"></i></button>
                <button id="redo-${windowId}" title="Redo (Ctrl+Y)" disabled><i class="fa-solid fa-redo"></i></button>
                <div class="separator"></div>
                <!-- Brush Tools -->
                <button class="tool active" data-tool="pencil" title="Pencil (Round)"><i class="fa-solid fa-pencil"></i></button>
                <button class="tool" data-tool="pixelBrush" title="Pixel Brush (Square)"><i class="fa-solid fa-vector-square"></i></button>
                <button class="tool" data-tool="sprayBrush" title="Spray Brush"><i class="fa-solid fa-spray-can-sparkles"></i></button>
                <button class="tool" data-tool="patternBrush" title="Pattern Brush"><i class="fa-solid fa-border-all"></i></button>
                <button class="tool" data-tool="crayonBrush" title="Crayon Brush"><i class="fa-solid fa-palette"></i></button>
                <button class="tool" data-tool="markerBrush" title="Marker Brush"><i class="fa-solid fa-highlighter"></i></button>
                <div class="separator"></div>
                <button class="tool" data-tool="eraser" title="Eraser"><i class="fa-solid fa-eraser"></i></button>
                <button class="tool" data-tool="fill" title="Fill Bucket"><i class="fa-solid fa-fill-drip"></i></button>
                <div class="separator"></div>
                <!-- Shape Tools -->
                <button class="tool" data-tool="line" title="Line"><i class="fa-solid fa-minus"></i></button>
                <button class="tool" data-tool="rect" title="Rectangle"><i class="fa-regular fa-square"></i></button>
                <button class="tool" data-tool="circle" title="Circle"><i class="fa-regular fa-circle"></i></button>
                <input type="checkbox" id="fill-shape-${windowId}" class="tool-option-toggle">
                <label for="fill-shape-${windowId}" title="Fill Shape"><i class="fa-solid fa-fill"></i> Fill</label>
                <div class="separator"></div>
                <!-- Color and Size -->
                <label for="color-${windowId}">Color:</label>
                <input type="color" id="color-${windowId}" value="#000000">
                <label for="size-${windowId}">Size:</label>
                <input type="range" id="size-${windowId}" min="1" max="50" value="5">
                <span class="size-indicator" id="size-indicator-${windowId}">5</span>
            </div>

            <div class="paint-main-content">
                <div class="paint-canvas-area" id="canvas-area-${windowId}">
                    <canvas id="canvas-${windowId}" class="paint-canvas"></canvas>
                    <canvas id="overlay-canvas-${windowId}" class="paint-overlay-canvas"></canvas>
                </div>
                <div class="paint-color-palette" id="color-palette-${windowId}"></div>
            </div>
        </div>`;

        const canvas = contentEl.querySelector(`#canvas-${windowId}`);
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const overlayCanvas = contentEl.querySelector(`#overlay-canvas-${windowId}`);
        const overlayCtx = overlayCanvas.getContext('2d');
        const toolbar = contentEl.querySelector('.top-toolbar');
        const colorPalette = contentEl.querySelector(`#color-palette-${windowId}`);
        const sizeSlider = contentEl.querySelector(`#size-${windowId}`);
        const colorPicker = contentEl.querySelector(`#color-${windowId}`);
        const sizeIndicator = contentEl.querySelector(`#size-indicator-${windowId}`);
        const fillShapeCheckbox = contentEl.querySelector(`#fill-shape-${windowId}`);
        const undoButton = contentEl.querySelector(`#undo-${windowId}`);
        const redoButton = contentEl.querySelector(`#redo-${windowId}`);

        let isDrawing = false, isDrawingShape = false;
        let currentTool = 'pencil', currentColor = '#000000', currentSize = 5;
        let lastX, lastY, startX, startY;
        let isFillingShapes = false;
        let canvasWidth = 500, canvasHeight = 400;
        let history = [], historyIndex = -1;

        function initialize() {
            setupColorPalette();
            setCanvasSize(canvasWidth, canvasHeight, false);
            saveState();
            updateUndoRedoButtons();
            setActiveTool('pencil');

            canvas.addEventListener('mousedown', handlePaintStart);
            canvas.addEventListener('mousemove', handlePaintMove);
            canvas.addEventListener('mouseup', handlePaintEnd);
            canvas.addEventListener('mouseleave', handlePaintLeave);

            toolbar.addEventListener('click', handleToolbarClick);
            fillShapeCheckbox.addEventListener('change', (e) => { isFillingShapes = e.target.checked; });
            colorPicker.addEventListener('input', (e) => { setColor(e.target.value); });
            sizeSlider.addEventListener('input', (e) => { currentSize = e.target.value; sizeIndicator.textContent = currentSize; });
            colorPalette.addEventListener('click', handlePaletteClick);

            const windowEl = openWindows[windowId]?.element;
            if (windowEl) {
                const handleKeyDown = (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key === 'z') { e.preventDefault(); undo(); }
                        else if (e.key === 'y') { e.preventDefault(); redo(); }
                    }
                };
                windowEl.addEventListener('keydown', handleKeyDown);
                if (openWindows[windowId]) {
                    openWindows[windowId].cleanup = () => { windowEl.removeEventListener('keydown', handleKeyDown); };
                }
            }
        }

        function saveState() {
            if (historyIndex < history.length - 1) history.splice(historyIndex + 1);
            history.push(canvas.toDataURL());
            historyIndex++;
            if (history.length > 30) { history.shift(); historyIndex--; }
            updateUndoRedoButtons();
        }

        function undo() { if (historyIndex > 0) { historyIndex--; restoreState(); } }
        function redo() { if (historyIndex < history.length - 1) { historyIndex++; restoreState(); } }

        function restoreState() {
            const img = new Image();
            img.onload = () => { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.drawImage(img, 0, 0); };
            img.src = history[historyIndex];
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            undoButton.disabled = historyIndex <= 0;
            redoButton.disabled = historyIndex >= history.length - 1;
        }

        function setCanvasSize(width, height, preserveContent = true) {
            let tempCanvas = null;
            if (preserveContent && canvas.width > 0) {
                tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                tempCanvas.getContext('2d').drawImage(canvas, 0, 0);
            }
            canvasWidth = width; canvasHeight = height;
            canvas.width = canvasWidth; canvas.height = canvasHeight;
            overlayCanvas.width = canvasWidth; overlayCanvas.height = canvasHeight;
            const bg = getComputedStyle(document.documentElement).getPropertyValue('--paint-canvas-bg-dark').trim() || '#ffffff';
            ctx.fillStyle = bg; ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (tempCanvas) ctx.drawImage(tempCanvas, 0, 0);
        }

        async function promptForCanvasSize() {
            const newWidth = await showOSPrompt('Enter new canvas width (px):', 'Resize Canvas', canvasWidth);
            if (newWidth === null || isNaN(newWidth) || newWidth <= 0) return;
            const newHeight = await showOSPrompt('Enter new canvas height (px):', 'Resize Canvas', canvasHeight);
            if (newHeight === null || isNaN(newHeight) || newHeight <= 0) return;
            setCanvasSize(parseInt(newWidth), parseInt(newHeight), true);
            saveState();
        }

        function handlePaintStart(e) {
            e.preventDefault(); // <-- FIX: Prevents the browser from dragging the canvas
            isDrawing = true;
            const pos = getMousePos(e);
            [startX, lastX] = [pos.x, pos.x];
            [startY, lastY] = [pos.y, pos.y];

            ctx.lineWidth = currentSize; ctx.strokeStyle = currentColor;
            ctx.fillStyle = currentColor; ctx.lineJoin = 'round';
            ctx.globalCompositeOperation = (currentTool === 'eraser') ? 'destination-out' : 'source-over';
            ctx.lineCap = (currentTool === 'pixelBrush' || currentTool === 'markerBrush') ? 'square' : 'round';

            overlayCtx.lineWidth = currentSize; overlayCtx.strokeStyle = currentColor;
            overlayCtx.fillStyle = currentColor; overlayCtx.lineJoin = 'round';
            overlayCtx.lineCap = 'round';
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

            if (currentTool === 'fill') {
                floodFill(startX, startY, currentColor);
                isDrawing = false; saveState(); return;
            } else if (['line', 'rect', 'circle'].includes(currentTool)) {
                isDrawingShape = true;
            } else {
                if (!['sprayBrush', 'patternBrush', 'crayonBrush', 'markerBrush'].includes(currentTool)) {
                    ctx.beginPath(); ctx.moveTo(lastX, lastY);
                }
                if (currentTool === 'pixelBrush') {
                    ctx.fillRect(startX - currentSize / 2, startY - currentSize / 2, currentSize, currentSize);
                }
            }
        }

        function handlePaintMove(e) {
            if (!isDrawing) return;
            const pos = getMousePos(e);
            const [cx, cy] = [pos.x, pos.y];

            if (isDrawingShape) {
                overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                drawShape(overlayCtx, startX, startY, cx, cy, isFillingShapes);
            } else {
                ctx.globalCompositeOperation = (currentTool === 'eraser') ? 'destination-out' : 'source-over';
                switch (currentTool) {
                    case 'pencil':
                    case 'eraser':
                        ctx.lineTo(cx, cy); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(cx, cy);
                        break;
                    case 'pixelBrush':
                        ctx.fillRect(cx - currentSize / 2, cy - currentSize / 2, currentSize, currentSize);
                        break;
                    case 'sprayBrush':
                        const sprayRadius = parseInt(currentSize);
                        const sprayDensity = 15 + sprayRadius / 2;
                        for (let i = 0; i < sprayDensity; i++) {
                            const angle = Math.random() * 2 * Math.PI;
                            const radius = Math.random() * sprayRadius;
                            ctx.fillRect(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius, 1, 1);
                        }
                        break;
                    case 'patternBrush':
                        const dist = Math.sqrt(Math.pow(cx - lastX, 2) + Math.pow(cy - lastY, 2));
                        const angle = Math.atan2(cy - lastY, cx - lastX);
                        ctx.lineWidth = 1; // Use a thin line for the pattern
                        for (let i = 0; i < dist; i += 5) {
                            const x = lastX + Math.cos(angle) * i;
                            const y = lastY + Math.sin(angle) * i;
                            const patternAngle = angle + Math.PI / 2;
                            ctx.beginPath();
                            ctx.moveTo(x - Math.cos(patternAngle) * currentSize, y - Math.sin(patternAngle) * currentSize);
                            ctx.lineTo(x + Math.cos(patternAngle) * currentSize, y + Math.sin(patternAngle) * currentSize);
                            ctx.stroke();
                        }
                        break;
                    case 'crayonBrush':
                        ctx.globalAlpha = 0.3; // Crayon texture
                        ctx.lineWidth = currentSize;
                        for (let i = 0; i < 5; i++) {
                            const dx = (Math.random() - 0.5) * currentSize * 0.5;
                            const dy = (Math.random() - 0.5) * currentSize * 0.5;
                            ctx.beginPath();
                            ctx.moveTo(lastX + dx, lastY + dy);
                            ctx.lineTo(cx + dx, cy + dy);
                            ctx.stroke();
                        }
                        ctx.globalAlpha = 1.0;
                        break;
                    case 'markerBrush':
                        ctx.globalAlpha = 0.5; // Semi-transparent marker
                        ctx.lineWidth = currentSize;
                        ctx.beginPath();
                        ctx.moveTo(lastX, lastY);
                        ctx.lineTo(cx, cy);
                        ctx.stroke();
                        ctx.globalAlpha = 1.0;
                        break;
                }
            }
            [lastX, lastY] = [cx, cy];
        }

        function handlePaintEnd(e) {
            if (!isDrawing) return;
            isDrawing = false;
            if (isDrawingShape) {
                overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                drawShape(ctx, startX, startY, getMousePos(e).x, getMousePos(e).y, isFillingShapes);
                isDrawingShape = false;
            } else {
                ctx.beginPath();
            }
            saveState();
        }

        function handlePaintLeave(e) { if (isDrawing) { handlePaintEnd(e); } }

        function drawShape(c, x1, y1, x2, y2, fill) {
            c.beginPath();
            if (currentTool === 'line') {
                c.moveTo(x1, y1); c.lineTo(x2, y2); c.stroke();
            } else if (currentTool === 'rect') {
                if (fill) c.fillRect(x1, y1, x2 - x1, y2 - y1);
                else c.strokeRect(x1, y1, x2 - x1, y2 - y1);
            } else if (currentTool === 'circle') {
                const radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                c.arc(x1, y1, radius, 0, 2 * Math.PI);
                if (fill) c.fill(); else c.stroke();
            }
        }

        function handleToolbarClick(e) {
            const button = e.target.closest('button');
            if (!button) return;
            if (button.dataset.tool) setActiveTool(button.dataset.tool);
            else if (button.id === `save-paint-${windowId}`) saveImage();
            else if (button.id === `resize-canvas-${windowId}`) promptForCanvasSize();
            else if (button.id === `clear-canvas-${windowId}`) clearCanvas();
            else if (button.id === `undo-${windowId}`) undo();
            else if (button.id === `redo-${windowId}`) redo();
        }

        function handlePaletteClick(e) {
            const colorBox = e.target.closest('.color-box');
            if (colorBox && colorBox.dataset.color) setColor(colorBox.dataset.color);
        }

        function setActiveTool(tool) {
            currentTool = tool;
            toolbar.querySelectorAll('.tool.active').forEach(b => b.classList.remove('active'));
            toolbar.querySelector(`button[data-tool="${tool}"]`)?.classList.add('active');
        }

        function setColor(color) { currentColor = color; colorPicker.value = color; }
        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
        }

        async function saveImage() {
            const filename = await showOSPrompt('Save image as:', 'Save Image', 'drawing.png');
            if (!filename) return;
            const link = document.createElement('a');
            link.download = filename.includes('.') ? filename : `${filename}.png`;
            link.href = canvas.toDataURL('image/png'); link.click();
        }

        async function clearCanvas() {
            if (await showOSConfirmDanger('Are you sure you want to clear the canvas?', 'Clear Canvas')) {
                setCanvasSize(canvasWidth, canvasHeight, false); saveState();
            }
        }

        function setupColorPalette() {
            const colors = ['#ffffff', '#c1c1c1', '#686868', '#000000', '#ff453a', '#ff9f0a', '#ffd60a', '#32d74b', '#64d2ff', '#0a84ff', '#bf5af2', '#ff375f'];
            colorPalette.innerHTML = colors.map(c => `<div class="color-box" data-color="${c}" style="background-color: ${c};" title="${c}"></div>`).join('');
        }

        function floodFill(startX, startY, fillColor) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const startPos = (startY * canvas.width + startX) * 4;
            const startR = data[startPos], startG = data[startPos + 1], startB = data[startPos + 2];
            const hexToRgb = (h) => ({ r: (parseInt(h.slice(1), 16) >> 16) & 255, g: (parseInt(h.slice(1), 16) >> 8) & 255, b: parseInt(h.slice(1), 16) & 255 });
            const fillRgb = hexToRgb(fillColor);
            if (startR === fillRgb.r && startG === fillRgb.g && startB === fillRgb.b) return;
            const pixelStack = [[startX, startY]];
            while (pixelStack.length) {
                const [x, y] = pixelStack.pop();
                const currentPos = (y * canvas.width + x) * 4;
                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) continue;
                if (data[currentPos] !== startR || data[currentPos + 1] !== startG || data[currentPos + 2] !== startB) continue;
                data[currentPos] = fillRgb.r; data[currentPos + 1] = fillRgb.g; data[currentPos + 2] = fillRgb.b; data[currentPos + 3] = 255;
                pixelStack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }
            ctx.putImageData(imageData, 0, 0);
        }

        initialize();
    }
},
